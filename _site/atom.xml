<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Reage blog</title>
 <link href="http://www.ireage.com/atom.xml" rel="self"/>
 <link href="http://www.ireage.com/"/>
 <updated>2016-11-18T14:23:08+08:00</updated>
 <id>http://www.ireage.com</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>服务治理</title>
   <link href="http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/16/servicemangger.html"/>
   <updated>2016-11-16T00:00:00+08:00</updated>
   <id>http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/16/servicemangger</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;服务治理&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么要做服务治理&lt;/h2&gt;

&lt;p&gt;一个系统在开发之初，功能简单，规模较小。 随着业务需求的变化和增加，
系统的功能和规模会变得庞大。&lt;/p&gt;

&lt;p&gt;将会出现以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;维护、开发、部署将变得困难&lt;/li&gt;
  &lt;li&gt;水平扩展困难&lt;/li&gt;
  &lt;li&gt;功能及技术迭代困难
（注：技术迭代指的是替换使用的语言、第三方工具等）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决上述的问题，我们将会采取分拆系统的方法，将一个庞大的系统拆分成N个小系统。&lt;/p&gt;

&lt;p&gt;拆分会带来以下的好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立部署，方便水平扩展&lt;/li&gt;
  &lt;li&gt;系统隔离&lt;/li&gt;
  &lt;li&gt;快速的迭代（每个系统可以根据业务场景来决定使用最优的开发语言和第三方工具）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，拆分并没有从根本上解决问题，随着业务发展，我们拆分出来的N个小系统会继续添加相关的业务，
随着时间的发展也变的复杂和庞大。我们又继续使用拆分的方案， 然后拆分出来的系统又随着业务的变化和发展，
开始从简单变得复杂，我们一遍又一遍做着重复拆分的事情。&lt;/p&gt;

&lt;p&gt;解决问题的方法是：&lt;/p&gt;

&lt;p&gt;在接到开发任务之初，将任务做成一个或者多个独立的服务单元（服务单元:请看下面注释），
每个服务单元单独部署和迭代开发，禁止添加其它非必要的功能。&lt;/p&gt;

&lt;p&gt;注解：&lt;/p&gt;

&lt;p&gt;服务单元：尽可能小的服务集合，只包含对于一个抽象属性的增删改查，杜绝添加其他相关联的功能和业务。&lt;/p&gt;

&lt;p&gt;随之带来的问题是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立的服务单元越来越多，如何对服务单元做管理&lt;/li&gt;
  &lt;li&gt;如何做负载均衡&lt;/li&gt;
  &lt;li&gt;如何做服务信息的修改及快速生效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最开始的解决方案是由OP和RD配合来做的。
通过DNS,NGINX,CONFIG文件来配合完成任务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DNS，NGINX都可以做负载均衡的功能。

DNS,NGINX,CONFIG都可以用来管理服务单元信息的变更
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的方法，虽然可以解决问题，但是每次必须修改配置，然后重新加载配置才会生效。
无法实现立即生效，避免错误继续扩大的问题。为了解决这些问题，就要使用有效的服务治理方案。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;服务治理&lt;/h2&gt;

&lt;p&gt;服务治理主要是对服务信息进行管理的一系列的系统。为了实现这个系统，
我们需要一个高可用、低延迟的数据存储工具。&lt;/p&gt;

&lt;p&gt;经过筛选我们最终选择了zookeeper。
我们先来看下zookeeper官方的定义：&lt;/p&gt;

&lt;p&gt;ZooKeeper is a centralized service for maintaining configuration information,
 naming, providing distributed synchronization, and providing group services.&lt;/p&gt;

&lt;p&gt;使用zookeeper原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公司已经有zookeeper集群，具备运维能力&lt;/li&gt;
  &lt;li&gt;zookeeper 使用范围比较广，&lt;/li&gt;
  &lt;li&gt;zookeeper watcher机制能够及时通知修改，保证信息一直&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然，我们可以通过zookeeper来解决存储数据的问题，
但是服务的信息并不会自动出现在zookeeper中，我们需要开发一个关于服务治理的系统。&lt;/p&gt;

&lt;p&gt;服务治理具备功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;服务发现&lt;/p&gt;

    &lt;p&gt;主动注册和第三方注册两种服务发现方式，我们现在使用的是第三方注册的方式，
 因为调用方和服务方都是PHP编写的，主动注册实现复杂&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务管理&lt;/p&gt;

    &lt;p&gt;服务状态的统计信息、服务信息管理、授权查看，在使用第三方注册时候，提供服务注册和修改功能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通信&lt;/p&gt;

    &lt;p&gt;异步通信和同步通信，现在只实现同步通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问控制&lt;/p&gt;

    &lt;p&gt;限制调用方使用的key对服务方访问频次、是否具有访问权限等检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据交互协议适配&lt;/p&gt;

    &lt;p&gt;调用方不用关注服务方提供服务使用的协议。目前支持http下json、yar-msgpack相互转换&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;如何去做&lt;/h2&gt;

&lt;p&gt;到目前为止，我找到解决问题的方法和需要实现的功能的。
根据上面的信息，我们给出了具体是的设计方案。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkmanagerservice.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个设计共分五部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;调用者&lt;/p&gt;

    &lt;p&gt;通过HTTP或YAR访问Gateway， 将需要调用的服务信息和参数告诉 Gateway，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务方&lt;/p&gt;

    &lt;p&gt;a) 提供服务&lt;/p&gt;

    &lt;p&gt;b) 将自己的信息通过管理平台注册到zookeeper中&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  1. 服务名、状态
  2. 地址信息、机房、权重及状态
  3. 服务下接口的列表
      a) 接口名
      b) 接口路径
      c) 输出数据的编码（json或者yar-msgpack）
      d) 状态
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Gateway&lt;/p&gt;

    &lt;p&gt;a) 请求的转发&lt;/p&gt;

    &lt;p&gt;b) 快速失败&lt;/p&gt;

    &lt;p&gt;c) 对发送的数据做编码（json或者yar-msgpack）&lt;/p&gt;

    &lt;p&gt;d) 负载均衡&lt;/p&gt;

    &lt;p&gt;e) 将服务和接口的信息缓存到内存中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管理平台&lt;/p&gt;

    &lt;p&gt;a) 服务及接口的注册&lt;/p&gt;

    &lt;p&gt;b) 服务及接口的查看&lt;/p&gt;

    &lt;p&gt;c) 服务及接口的修改&lt;/p&gt;

    &lt;p&gt;d) 统计信息查看&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZooKeeper&lt;/p&gt;

    &lt;p&gt;ZooKeeper在整个服务治理的设计中是最重要的组成部分。
在使用zookeeper之前。我们先来看下zookeeper存储数据的原理。
下面是zookeeper官方的介绍:&lt;/p&gt;

    &lt;p&gt;The name space provided by ZooKeeper is much like that of a standard file system. 
A name is a sequence of path elements separated by a slash (/). 
Every node in ZooKeeper’s name space is identified by a path.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://zookeeper.apache.org/doc/r3.1.1/images/zknamespace.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zookeeper就像一个树，用每一个”/{name}”表示节点及节点名。每一个节点可以有子节点和存储少量的内容。&lt;/p&gt;

&lt;p&gt;我们在zookeeper中存储的信息有服务信息、地址信息、接口信息。具体格式如下：&lt;/p&gt;

&lt;p&gt;服务信息：/service/{服务名}&lt;/p&gt;

&lt;p&gt;地址信息：/address/{服务名}&lt;/p&gt;

&lt;p&gt;接口信息：/api/{服务名}/{接口名}&lt;/p&gt;

&lt;p&gt;为什么要将zookeeper中存储数据的结构设计为上面描述格式， 是因为zookeeper在watcher机制的处理中给出了
   两个关于wather 通知使用的API（golang zk）
   一个是关注子节点变化ChildrenW函数，另外一个是关注节点本身内容变化GetW函数。
   我们设计的方案在实现上让每个节点功watcher更加简单。
   我们现在来看一个具体的例子：假设有一个服务s，下面有A,B两个接口
&lt;img src=&quot;/img/zkstoragestructrue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;zookeeper&quot;&gt;出现的问题（如何保证缓存信息和zookeeper中的内容一致）&lt;/h2&gt;

&lt;p&gt;Gateway 为了做到低延迟和高可用性，在Gateway 中缓存zookeeper中的数据。
在Gateway中缓存数据的格式与zookeeper中的结构一致。
我们是如何保证缓存的信息是正确可用的,
就需要用到zookeeper的watcher机制。在zookeeper中内容中修改时，
通过watcher机制通知Gateway 来更新缓存&lt;/p&gt;

&lt;p&gt;具体的设计如下图（具体实现的流程图在最后）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkwatcherdesign.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了设计图可能会有下列的疑问：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么收到通知后不直接去更新缓存？&lt;/p&gt;

    &lt;p&gt;这个问题就需要了解zookeeper关于watcher机制的原理，zookeeper的watcher机制是一次性的，
 在收到watcher的通知后，watcher就消失了。为了避免在更新缓存时zookeeper的
 数据再次变化无法收到通知，因为这个时候watcher机制已经没有，
 zookeeper已经没有通知Gateway机制，这样缓存中的数据和zookeeper中的数据将会不一致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么致命错误需要重新初始化缓存？&lt;/p&gt;

    &lt;p&gt;下面的介绍的内容会跟开发使用的语言和zookeeper的sdk有一定的关系。&lt;/p&gt;

    &lt;p&gt;开发语言：golang   — SDK：samuel/go-zookeeper/zk&lt;/p&gt;

    &lt;p&gt;我们先来看下SDK是如何处理错误，
 个人将SDK的错误分为非致命错误和致命错误错误两种（个人观点）。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 非致命错误：ErrNoAuth、ErrAPIError、ErrAuthFailed等

 致命错误：ErrSessionMoved、ErrSessionExpired等
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;非致命错误是与zookeeper集群通信时，使用的参数及上下文环境出现问题返回的错误，
 影响范围只有本次调用。&lt;/p&gt;

    &lt;p&gt;致命错误通常是与zookeeper集群的通信出现网络故障，影响与zookeeper集群的所有通信。
 但是SDK(go-zookeeper)并不会在问题出现时刻立即报错，
 SDK会自动尝试建立新的可以使用的session，
 SDK在session建立成功后将给所有的watcher发送一个错误通知。&lt;/p&gt;

    &lt;p&gt;ErrSessionMoved: 是与zookeeper集群的某个实例session失效后，
 下次与zookeeper成功建立session发送给所有watcher。&lt;/p&gt;

    &lt;p&gt;ErrSessionExpired:是与整个zookeeper集群session失效后，
 下次与zookeeper成功建立session发送给所有watcher。&lt;/p&gt;

    &lt;p&gt;收到致命错误后，我们无法知道在于zookeeper集群session断开的时间段中，
 zookeeper中的数据数据变化情况。如果只是更新和新加，
 我们可以在初始化的时候将节点的内容缓存即可，
 但是如果有删除的话。我们就需要遍历所有的缓存内容来删除不需要的缓存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现的流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkwatcherprocess.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>服务治理之zookeeper使用中遇到的问题及设计</title>
   <link href="http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/08/service_zookeeper.html"/>
   <updated>2016-11-08T00:00:00+08:00</updated>
   <id>http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/08/service_zookeeper</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;如何规划需要管理配置&lt;/h1&gt;

&lt;p&gt;根据需求将所有的信息分成四类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 分类

    /classify下每个节点是一个分类名，内容是分类描述，分类属于辅助信息，没有太大意义。

    eg: /classify/c1  分类名c1, /classify/c1节点内容为c1的描述

2. 服务信息

    /service下每个节点都是一个服务

    eg: /service/srv1  服务名为srv1，/service/c1节点内容服务srv1具体内容

3. 服务地址

    /address 下每个节点都是一个服务

    eg: /service/srv1  服务名为srv1，/service/c1节点内容服务srv1具体内容

4. 服务下的API

    /api下每一个节点是一个服务，服务下节点是API的命名的节点

    eg: /api/srv1/api1   /api/srv1下的子节点是srv1服务下的所有API，/api/srv1/api1  服务srv1下api1的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;问题&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1. zk reconnect后授权问题

2. zk session 过期

3. zk reconnect 数据同步的问题

2. watcher 消失后修改的问题
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;功能设计&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zk&lt;/td&gt;
      &lt;td&gt;1.管理节点&amp;lt;/br&amp;gt;2.内容节点&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;watcher&lt;/td&gt;
      &lt;td&gt;1.关注子节点变化&amp;lt;/br&amp;gt;2.关注本身变化&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;queue&lt;/td&gt;
      &lt;td&gt;1.处理错误&amp;lt;/br&amp;gt;2.重新初始化监控&amp;lt;/br&amp;gt;3.初始化缓存&amp;lt;/br&amp;gt;4.通知cache变更&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cache&lt;/td&gt;
      &lt;td&gt;1.根据类型更新缓存&lt;/td&gt;
      &lt;td&gt;所有缓存相关的操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-3&quot;&gt;好处&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1. 各模块职责单一

2. 统一的错误处理

3. 收敛缓存处理逻辑

4. 方便扩展
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-4&quot;&gt;解决问题方法&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;zk reconnect后授权问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zk session 过期&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zk reconnect 数据同步的问题&lt;/p&gt;

    &lt;p&gt;问题1、2、3 在queue模块中添加统一的错误处理逻辑&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;添加授权信息&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关闭原有的watcher&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;初始化watcher进程&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;watcher 消失后修改的问题&lt;/p&gt;

    &lt;p&gt;通过设计queue和cache模块，分开实现，延时获取数据的。&lt;/p&gt;

    &lt;p&gt;具体流程，见下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://7xi8r0.com1.z0.glb.clouddn.com/watcher_note.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>服务治理之服务管理</title>
   <link href="http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/07/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.html"/>
   <updated>2016-11-07T00:00:00+08:00</updated>
   <id>http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/07/服务治理之服务管理</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;如何管理服务&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;需要考虑的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 1. 服务信息注册

* 2. 如何保证服务信息一致
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务信息是服务发现很重要的部分，它是包含服务提供者的地址信息和提供服务的接口。
服务信息需要高可用而且随时更新。gateway可以缓存从服务信息。
然而，这些信息最终会变得过时，客户端也无法发现服务实例。
因此，服务信息必须保证是一个一个分布式可用。&lt;/p&gt;

&lt;h6 id=&quot;section-1&quot;&gt;目前可以使用的组件有：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;etcd

consul

zookeeper

Kubernetes

eureka
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，根据公司运维等方面考虑选择使用zookeeper&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;主要实现功能&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 服务发现

   主动注册和被动注册，我使用的是被动注册，因为调用方和服务方都是PHP，主动注册不方便

2. 服务管理

  由于是被动注册，需要提供一个注册平台，主要提服务注册、授权、地址等信息管理

3. 通信

   异步通信和同步通信，现在只实现同步通信

4. 访问控制

   限制调用放key对服务方QPS、接口、有效时长

5. 数据交换编码

    目前支持http下json、yar-msgpack相互转换
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;zookeeper&quot;&gt;基于zookeeper服务管理的实现&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkmanagerservice.png&quot; alt=&quot;基于zookeeper服务管理的实现图&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>服务治理之开发环境配置解决</title>
   <link href="http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/10/06/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
   <updated>2016-10-06T00:00:00+08:00</updated>
   <id>http://www.ireage.com/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/10/06/服务治理之开发环境配置</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;出现的问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;新搭建的开发环境如何快速使用&lt;/li&gt;
  &lt;li&gt;如何解决开发中路由问题（同一个服务或者接口不同调用者调用不同服务方）&lt;/li&gt;
  &lt;li&gt;如何解决开发中使用host的问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;为什么测试环境和生产环境没有问题&lt;/h3&gt;

&lt;p&gt;测试和生产环境在服务和接口的环境调用比较简单，都是一一对应的。
在使用的过程中，服务治理这不需要关注调用者身份，只需根据服务中配置的
地址信息，选择一个可用的服务者来转发这个请求即可。&lt;/p&gt;

&lt;p&gt;但是在开发环境中，服务和接口调用者关系比较复杂。我将调用者分成两种类型，
直接调用者和间接调用者。间接调用者的需求是最简单的，这个服务或者接口
我不需要关心，只要能返回结果。 直接调用者需求是最复杂的，直接调用者有非常
明确的服务提供者，有可能是整个服务下的接口，也有可能是服务下摸个接口。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;没有服务治理之前怎么解决&lt;/h3&gt;

&lt;h6 id=&quot;section-3&quot;&gt;使用服务治理前&lt;/h6&gt;

&lt;p&gt;调用者和服务方是直接通信的，所有环境的配置都是在代码配置文件中，调用者可以
直接指定服务方地址。可以同修改配置文件和/etc/hosts文件来决定服务方&lt;/p&gt;

&lt;h6 id=&quot;section-4&quot;&gt;使用服务治后&lt;/h6&gt;

&lt;p&gt;调用者和服务方是间接通信的， 服务治理做为中间方。调用者和服务方直接通信都是
服务治理的提供者。修改本地配置失效。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;服务治理只在服务信息和接口信息中新加路由表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;调用者&lt;/th&gt;
      &lt;th&gt;调用者&lt;/th&gt;
      &lt;th&gt;服务者&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;测试ip1&lt;/td&gt;
      &lt;td&gt;127.0.0.1&lt;/td&gt;
      &lt;td&gt;http://apiv1.ireage.com&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;测试ip2&lt;/td&gt;
      &lt;td&gt;127.0.0.1&lt;/td&gt;
      &lt;td&gt;http://apiv2.ireage.com&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在服务信息中新加域名信息domain: http://api.ireage.com&lt;/p&gt;

&lt;h6 id=&quot;section-6&quot;&gt;1. 新搭建的开发环境如何快速使用&lt;/h6&gt;
&lt;p&gt;每一个服务需要一个默认可以使用的地址&lt;/p&gt;

&lt;h6 id=&quot;section-7&quot;&gt;2. 如何解决开发中路由问题（同一个服务或者接口不同调用者调用不同服务方）&lt;/h6&gt;
&lt;p&gt;服务和接口分别有host的配置，通过调者IP地址来决定服务方的地址&lt;/p&gt;

&lt;h6 id=&quot;host&quot;&gt;3. 如何解决开发中使用host的问题&lt;/h6&gt;

&lt;p&gt;为服务配置一个域名，在http的头部添加host即可。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>react</title>
   <link href="http://www.ireage.com/react/2016/09/27/reacterr.html"/>
   <updated>2016-09-27T00:00:00+08:00</updated>
   <id>http://www.ireage.com/react/2016/09/27/reacterr</id>
   <content type="html">&lt;h3 id=&quot;commpont&quot;&gt;同一个commpont多次使用出现的错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;错误提示如下：
 Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded

 解决方法如下
 npm uninstall react react-dom
 npm install react react-dom --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setstate&quot;&gt;setState有延时&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.setState(params:{page:2});
随后使用fetch将this.state.params作为参数获取数据的时候，竟然是之前的数据
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP VS GO</title>
   <link href="http://www.ireage.com/%E6%9D%82%E8%B0%88/2016/08/30/phpvsgo.html"/>
   <updated>2016-08-30T00:00:00+08:00</updated>
   <id>http://www.ireage.com/%E6%9D%82%E8%B0%88/2016/08/30/phpvsgo</id>
   <content type="html">&lt;h4 id=&quot;section&quot;&gt;整体印象&lt;/h4&gt;
&lt;p&gt;PHP：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 不用编译，写完代码就可以直接看
2. 只要本次执行的代码没有fatal就可以执行，即使优点也是缺点。
3. 弱类型超牛B，一个变量随便用，不用声明，数组随意递归没有格式限制。 即使优点也是缺点
4. 特别讨厌$，
5. 强大string，array操作
6. 成熟访问权限控制public,private,protected
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 每次写完都需要编译。 需要检查整个项目编译，整个项目没有错误。
2. 严格的格式，强类型。 变量定义必须使用，代码格式etc
3. 简介的格式
4. 强大的协程
5. 完善的网络库
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;语法相关&lt;/h4&gt;
&lt;p&gt;PHP：&lt;/p&gt;

&lt;p&gt;觉得自己不是一个合格PHPer,使用两年多了，竟然总结不出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 自由灵活，变量，命名，语法灵活
2. 入门简单
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 访问权限，通过大小写控制，小写内部函数，大写外部函数。（刚开始特别坑，让我一个经常使用驼峰命名的人很不习惯）
2. defer个人感觉超级好用，可以用来做释放资源，后期处理。
3. 变量，类型超级丰富，觉得虽然和接触的语言都不一样，但是感觉超级习惯，var xxx type
4. 函数定义，丰富的数据传递参数，个人理解一个最完整 func (共有数据) 函数名(函数私有数据)（返回数据），
5. 没有类，但是可以使用struct 和 interface 来完成。interface在GO里面很重要的
6. channel，协程为并发而生。
7. 把异步搞的和同步一样
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;适用场景&lt;/h4&gt;

&lt;p&gt;PHP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. WEB开发
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1. WEB开发
 2. 服务开发
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;题外话&lt;/h4&gt;

&lt;p&gt;######进程、线程、协程
进程和线程比较常见，操作系统课上都讲过，协程虽然没有讲过），如果知道nginx原理相信会觉得似曾相识
其实可以从调度、并发性、系统开销、拥有资源等发面作比较&lt;/p&gt;

&lt;p&gt;进程：&lt;/p&gt;

&lt;p&gt;进程被称为重量级别进程（HWP）。进程也可看做一个线程的集合，在我看来进程管理者是操作系统
进程的调度是有OS来调度和管理。所以进程的调度，并发，系统开销、资源拥有都是系统层面。&lt;/p&gt;

&lt;p&gt;线程：&lt;/p&gt;

&lt;p&gt;线程被称为轻量级别的进程（LWP）是CPU调度和分配的基本单元。在我看来线程是一个CPU执行的实例。是一个进程获取到执行时内部调度，并发。&lt;/p&gt;

&lt;p&gt;进程和线程intel网站上有一份超级详细和全面的资料。&lt;a href=&quot;https://software.intel.com/sites/default/files/m/5/7/f/a/b/12568-2.1.1_e7_ba_bf_e7_a8_8b_e4_b8_8e_e8_bf_9b_e7_a8_8b_e7_9a_84_e5_8c_ba_e5_88_ab.pdf&quot;&gt;process vs threads.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;协程:
协程是一个不能被操作系统和CPU调度的玩意，全靠语言本身来控制。不关是进程，线程调度的时候都要进行上下文切换， 协程这玩意不涉及系统和CPU的上下文切换，协程个人感觉是就是异步和内存切换。
附带一篇不错协程介绍&lt;a href=&quot;http://blog.imisko.com/2017/08/02/golang-coroutine/&quot;&gt;Golang协程之殇&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>c pointer</title>
   <link href="http://www.ireage.com/c/2016/08/21/cpointer.html"/>
   <updated>2016-08-21T00:00:00+08:00</updated>
   <id>http://www.ireage.com/c/2016/08/21/cpointer</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;指针相关&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;glibc-detected--19-munmapchunk-invalid-pointer-0x00007ffff5cc97b0-&quot;&gt;1.&lt;em&gt;** glibc detected **&lt;/em&gt; ./19: munmap_chunk(): invalid pointer: 0x00007ffff5cc97b0 ***&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; a) free释放内存出现，注意free只能释放malloc分配的内存，在function中看到是指针，这个指针有可能是定义的数组，无法释放
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;type--type-&quot;&gt;2. 二维数组和指针的指针区别( type [][]与 type **)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  虽然两种方式在使用的时候访问方式是通用的，差异主要在内存组织

  二维数组是一个连续的区域，如char a[2][3] 实际上是一个连续的sizeof(char)*2*3的内存区域。在变量定义时候已经确立整数组存储数据集合容纳数据大小，
  并且没一行数据的个数必须一样，无法扩容;


  指针指针是是通过先分配type * 来存储二维数组中一维，然后在分配type 来维持二维数组二维。存储数据集合和动态调整，没一行的个数可以不同。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:内存组织图，type标识数据类型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arrayandpointerpointer.png&quot; alt=&quot;内存组织图&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>iterm2 快捷键</title>
   <link href="http://www.ireage.com/iterm2/2016/08/11/iterm2keys.html"/>
   <updated>2016-08-11T00:00:00+08:00</updated>
   <id>http://www.ireage.com/iterm2/2016/08/11/iterm2keys</id>
   <content type="html">&lt;p&gt;最近买了一个键盘，操作触控就不方便了，只能在键盘下功夫了。&lt;/p&gt;

&lt;p&gt;本人系统shell是zsh&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;&lt;strong&gt;光标操作&lt;/strong&gt;&lt;/h4&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;ctrl + a: 到行首

ctrl + e: 行末

ctrl + f/b: 前进后退，相当于左右方向键。

ctrl + p: 上一条命令，相当于方向键上

ctrl + r: 搜索命令历史，这个大家都应该很熟悉了

ctrl + d: 删除当前字符

ctrl + h: 删除之前的字符

ctrl + w: 删除光标前的单词

ctrl + k: 删除到文本末尾

ctrl + t: 交换光标处文本

ctrl + u: 删除一行

command + —/+/0: +字体变大，-字体变小， 0 恢复到默认值，如果分屏了只调整活动窗口字体大小

command + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。对 ⌘ + f没有影响
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;窗口操作&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;shift + command + d: 水平拆分窗口

shift + d: 垂直拆分窗口

command + shift + w: 关闭当前活动终端窗口

command + `/~ : 前一个/后一个窗口, 这里的窗口不是tab页面，而是通过new window打开的多个终端窗口

command + t: 在活动终端新建一个tab标签

command + w: 关闭当前tab窗口

command + option + 上下左右: 在当前活动的tab标签切换到上/下/左/右面板，面板指的是水平/垂直拆分的窗口

command + enter: 进去/退出全屏木事

Command + u: 开启/关闭背景透明

shift + command + [/]: 前一个/后一个标签页

command + option + +: 进入/退出铺满屏幕

 command + ctrl+ 上/下/左/右 : 调整当前分屏边框大小，
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h4&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;command + shift + m: 新建书签

command + shift + j: 回到最后一次简历书签的位置


command + shift + h: 展示粘贴历史，支持模糊检索

command + option + b: 打开即使回放

command + /: 显示光标的位置
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>json_decode解析失败</title>
   <link href="http://www.ireage.com/php/2016/02/24/json_decode.html"/>
   <updated>2016-02-24T00:00:00+08:00</updated>
   <id>http://www.ireage.com/php/2016/02/24/json_decode</id>
   <content type="html">&lt;p&gt;最近，一直在使用的系统突然出现一个奇怪的问题。一个商户信息总是没法展示的，两个系统采用json做的数据交换，
线上日志记录到模块是接受导数据，但是在后面的日志中，发现数据为空。经过在线上加log发现json_decode失败的返回值为NULL。
随后把log中的日志拿出来，json_decode没有问题的。&lt;/p&gt;

&lt;p&gt;首先想到的问题是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;json格式的问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存限制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编码问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的问题，很容就可以检查结果了。到底是不是这些原因的。不幸的事情发生了。这些都不是的，太奇葩了。&lt;/p&gt;

&lt;p&gt;虽有用json_decode解码失败搜索发现，有人说是因为json串有\t等特殊字符的问题的（之所以copy后解析成功，是因为不同的编辑器和编码格式会对特殊字符做处理）。&lt;/p&gt;

&lt;p&gt;在不同的终端下查看数据，发现数据中有特符符号。但是并不是\t,而是编码格式为\u0014\u0017数据。最好建议大家不要对数据进行解码查看，要看查看最原始的数据。因为不同的编码会对特殊符号做处理，在不同的编码下，特殊符号可能会显示为空白，不显示，显示为不同的符号等。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>php extensions(二) phpinfo输出内容</title>
   <link href="http://www.ireage.com/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/18/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(%E4%BA%8C)phpinfo%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF.html"/>
   <updated>2015-04-18T00:00:00+08:00</updated>
   <id>http://www.ireage.com/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/18/php扩展开发学习(二)phpinfo添加信息</id>
   <content type="html">&lt;h3 id=&quot;php-extensions--phpinfo&quot;&gt;php extensions(二)  phpinfo输出内容&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;引言&lt;/h4&gt;

&lt;p&gt;我们在使用一个PHP扩展的时候，首先，将编译后的扩展放到PHP的扩展加载目录下，使用phpinfo函数来查看插件是否已经加载。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;代码实现&lt;/h4&gt;

&lt;p&gt;在phpinfo函数添加内容特别简单的。
   1.首先修改module entry&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;zend_module_entry reage_module_entry = {
             STANDARD_MODULE_HEADER,
             &amp;quot;reage&amp;quot;,//扩展的名字
             NULL, // functions
             NULL, // minit
             NULL, //mshutdown
             NULL, //rinit
             NULL, //rshutdown
             PHP_MINFO(reage_info), //注册在phpinfo函数中输出内容的函数,reage_info
             &amp;quot;0.0.1&amp;quot;, //版本号
             STANDARD_MODULE_PROPERTIES
         };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2.输出内容函数的实现&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;PHP_MINFO_FUNCTION(reage_info) {
           php_info_print_table_start();
           php_info_print_table_header(2, &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;);
           php_info_print_table_row(2, &amp;quot;author&amp;quot;, &amp;quot;Reage&amp;quot;);
           php_info_print_table_end();
        }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用到的函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;php_info_print_table_start();
php_info_print_table_header();
php_info_print_table_row();
php_info_print_table_end();

除了这些函数，还有很多函数，需要的话请自行查阅
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####  源代码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng/php-extension-learn/tree/master/learn2(phpinfo)&quot;&gt;https://github.com/rentiansheng/php-extension-learn/tree/master/learn2(phpinfo)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;特别说明&lt;/h4&gt;

&lt;p&gt;在搜索资料时，发现一个写的特别好的php扩展开发系列文章，希望对大家有用&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.walu.cc/phpbook/index.md&quot;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>php extensions(-) 代码目录结构</title>
   <link href="http://www.ireage.com/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/08/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(-).html"/>
   <updated>2015-04-08T00:00:00+08:00</updated>
   <id>http://www.ireage.com/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/08/php扩展开发学习(-)</id>
   <content type="html">&lt;h3 id=&quot;php-extensions--&quot;&gt;php extensions(-) 代码目录结构&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;引言&lt;/h4&gt;
&lt;p&gt;每一个php extension的目录中最少要包含config.m4、config.w32、php_extension.h、extension.c。php_extension.h和extension.c文件是以后编写php extension主要用到文件，这里就不介绍了。下面我们开一个叫reage的php extension。&lt;/p&gt;

&lt;h4 id=&quot;configm4configw32&quot;&gt;1. 扩展的配置文件config.m4和config.w32&lt;/h4&gt;

&lt;p&gt;config.m4用户Unix、Linux等系统。config.m4文件告诉 UNIX 构建系统哪些扩展 configure 选项是支持的，你需要哪些扩展库，以及哪些源文件要编译成它的一部分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  config.m4配置函数PHP_ARG_WITH()和 PHP_ARG_ENABLE()的区别在于编译的时候使用 --with-* 选项还是 --enable-* 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/internals2.structure.files.php&quot;&gt;关于配置文件的详细内容&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是我的一个例子&lt;/p&gt;

&lt;p&gt;dnl在config.m4是注释的意思&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;PHP_ARG_WITH(reage, for reage support,
Make sure that the comment is aligned:
[  --with-reage             Include reage support])
dnl 检测扩展是否已启用
if test $PHP_REAGE != &amp;quot;no&amp;quot;; then
    PHP_SUBST(REAGE_SHARED_LIBADD)
    PHP_NEW_EXTENSION(reage, reage.c, $ext_shared)
fi&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;config.w32 是windows下的扩展的配置文件的，&lt;a href=&quot;http://php.net/manual/zh/internals2.structure.files.php&quot;&gt;具体使用查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;####2. php_reage.h&lt;/p&gt;

&lt;p&gt;php_reage.h其实不是必须的，但是一般的都C语言项目都是包含.h和.c文件的。为了让代码看起来更加的正规，我们也使用.h文件。.h文件一般只包含函数的定义、结构体的定义。&lt;/p&gt;

&lt;p&gt;下面是我的一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#ifndef REAGE_H
#define REAGE_H


#include &amp;quot;php.h&amp;quot;
#define phpext_reage_ptr &amp;amp;reage_module_entry;
extern zend_module_entry reage_module_entry;

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;####3. reage.c
reage.c是具体的代码文件的。
下面是我的一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;php_reage.h&amp;quot;
#include &amp;quot;ext/standard/info.h&amp;quot;

//加载config.h,如果有配置项
#ifdef HAVE_CONFIG_H
#include &amp;quot;config.h&amp;quot;
#endif


//module entry
zend_module_entry reage_module_entry = {
    STANDARD_MODULE_HEADER,
    &amp;quot;reage&amp;quot;,//扩展的名字
    NULL, // functions
    NULL, // minit
    NULL, //mshutdown
    NULL, //rinit
    NULL, //rshutdown
    NULL,
    &amp;quot;0.0.1&amp;quot;, //版本号
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_REAGE
ZEND_GET_MODULE(reage)
#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;####4. 编译php extension
   在php extension的目录下，执行一下命名:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
   1. phpize
   2. ./configure
   3. make
   4. make test
  &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;####5. test 
    将modules/reage.so 拷贝到你php的extension路径中。不知道路径的话，看下phpinfo()中extension_dir的值就可以了。然后修改php.ini添加extension=reage.so。如果没有问题，在phpinfo()中会现实reage及其版本。&lt;/p&gt;

&lt;p&gt;####6. ext_skel
  ext_skel工具是专门用来生成php extension 目录结构的。ext_skel在php源码下的ext目录下。
  使用ext_skel工具生成目录结构后，需要修改config.m4中大约10-20行，是关于PHP_ARG_WITH和PHP_ARG_ENABLE的。根据自己的需要将前面的注释符号（dnl）去掉&lt;/p&gt;

&lt;p&gt;####7. 源代码
&lt;a href=&quot;https://github.com/rentiansheng/php-extension-learn/tree/master/learn1&quot;&gt;https://github.com/rentiansheng/php-extension-learn/tree/master/learn1&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mysql 优化基础知识（-）</title>
   <link href="http://www.ireage.com/mysql/2015/03/30/mysql%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(-).html"/>
   <updated>2015-03-30T00:00:00+08:00</updated>
   <id>http://www.ireage.com/mysql/2015/03/30/mysql优化基础知识(-)</id>
   <content type="html">&lt;h4 id=&quot;primary-key&quot;&gt;1. primary key&lt;/h4&gt;
&lt;p&gt;primary key是聚簇索引，聚餐适用I/O密集型的应用，由于底层存储及实现的原因，聚簇索引严重依赖顺序存储，聚簇索引列更新代价比较高，聚簇索引列在尾部以外插入新的row代价比较高的
  综上所述，在使用primary key列一般都是用int类型auto_increment，这样保证所有的值都是顺序插入的，auto_increment在高并发的应用下肯定会有争用问题。
  主键的优点在于不管表中有多少行数据。通过primary key获取数据都非常快&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;2.索引在存储时都是正序存储&lt;/h4&gt;
&lt;p&gt;因此，就算建立 index idx_score_course(score,course) 索引，使用explain “select * from test order by score desc, course asc”你就会发现并没有到idx_score_course索引，在Extra现实这Using filesort&lt;/p&gt;

&lt;h4 id=&quot;where-in&quot;&gt;3. where in&lt;/h4&gt;
&lt;p&gt;mysql中的where in与or是不同的，mysql不回将where in转换成or，mysql会对where in的条件进行排序，然后做二分查找，这是一个时间复杂度为o(log n)的操作，等价转换成or的查询时间复杂度为o(n)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>codeigniter rabbitmq lirary</title>
   <link href="http://www.ireage.com/php/2014/11/28/codeigniter-rabbitmq-library.html"/>
   <updated>2014-11-28T00:00:00+08:00</updated>
   <id>http://www.ireage.com/php/2014/11/28/codeigniter rabbitmq library</id>
   <content type="html">&lt;p&gt;简介
&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;_&lt;/p&gt;

&lt;p&gt;针对CI 封装的一个简单的rabbitmq，只有基本功能的&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng//ci-rabbitmq&quot;&gt;项目地址：https://github.com/rentiansheng//ci-rabbitmq&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;代码结构&lt;/h2&gt;
&lt;p&gt;1.文件介绍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.src/src/libraries/rabbitmq.php  rabbitmq操作代码
  2.src/src/config/rabbitmq.php     rabbitmq配置文件
  3.src/src/models/rabbitmqmodel.php   consume回调函数代码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.将需要的PHP代码文件放到制定位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1. cp src/src/libraries/rabbitmq.php   项目代码/application/libraries/
  2. cp src/src/config/rabbitmq.php   项目代码/application/config/
  3. cp src/src/models/rabbitmqmodel.php   项目代码/application/models/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;1.queue  declare一个queue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   参数
       name 队列的名字
       durable queue是否持久化，true，是，false 否 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.sendMsg 向队列中add内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    参数
        msg 消息的内容
        exchangeName 发送消息使用的exchangeName
        queueName 接受消息的queue
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
        exchangeType exchage type 我一般用直接写入，
                      你可以选择一下模式， AMQP_EX_TYPE_DIRECT,
                      AMQP_EX_TYPE_FANOUT,
                      AMQP_EX_TYPE_HEADER or AMQP_EX_TYPE_TOPIC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.getMsg 获取消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   参数 
        queueName 获取内容的queue的name
        autoack   是否自动ack，autoack ＝ true，消息将从队列删除，
                  autoack ＝ false；时，需要用ack或者nack来回应给rabbitmq，否则，队列将无法工作
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
    备注
        从队列中的下一个可用的消息。如果没有消息存在于队列中，该函数将立即返回FALSE，
        这种方式比较消耗CPU,不建议使用的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.consume 获取消息，推荐&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    参数
        queueName 获取内容的queue的name
        callback  回调函数的名字，注意这个是函数名字的，对应名字的函数必须在models/rabbitmqmodel.php中实现的
        autoack   是否自动ack，autoack ＝ true，消息将从队列删除，
                  autoack ＝ false；时，需要用ack或者nack来回应给rabbitmq，否则，队列将无法工作
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
    备注
        callback回调函数的名字，注意这个是函数名字的，对应名字的函数必须在models/rabbitmqmodel.php中实现的
        回调函数将会有两个参数，
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.consume回调函数格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   function test(envelope, $queue) {}
    参数
       envelope  与消息相关的对象，具体的查看&amp;lt;a href=&quot;http://php.net/manual/pl/class.amqpenvelope.php&quot;&amp;gt;http://php.net/manual/pl/class.amqpenvelope.php&amp;lt;/a&amp;gt;
       queue  queue的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;demo-&quot;&gt;demo 目录下是示例代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 将demo/controllers/taskqueue.php 项目代码/application/controllers/taskqueue.php
2.  运行例子，最好可以terminal运行,首先转到项目文件所在的路径
    已发送消息作为例子
    sudo [可选择加上php env]  php所在位置 index.php taskqueue   sendMsg 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;我遇到的问题&lt;/h2&gt;
&lt;p&gt;1.在执行一段时间后无法从redis获取内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    我使用的是ci的cache库操作redis，由于cache 初始化是在controller开始的位置，时间久了，会自动断开链接请注意。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.请不要在浏览器中运行consume， php-fpm有可会出现问题，&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>览器桌面通知（notifications）</title>
   <link href="http://www.ireage.com/js/2014/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5-notifications.html"/>
   <updated>2014-05-28T00:00:00+08:00</updated>
   <id>http://www.ireage.com/js/2014/05/28/浏览器桌面通知（notifications）</id>
   <content type="html">&lt;h1 id=&quot;chrome-&quot;&gt;chrome 浏览器桌面通知&lt;/h1&gt;

&lt;p&gt;最近在做公司后台管理系统，当有任务到来时，需要通知当事人，但是，当事人有可能在做别的事情，更糟糕的是浏览器有可能会被最小化，
这样就很难看到通知了。经过查找发现有些浏览器可以使用noitfications，
可以在桌面的通知区域内显示一个提示框，并且显示在桌面的最前面，很方便就能看到了。我就将它简单的封装一下，使其符合常用的使用场景。
功能效果类似webQQ的消息提示通知。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng/notification&quot;&gt;项目地址：https://github.com/rentiansheng/notification&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;用于其余B/S下的网络办公提醒功能。
页面最小化的状态下发送通知
依然显示在屏幕的右下角，马上可以看到内容&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;依赖&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;PC chrome浏览器。&lt;/li&gt;
  &lt;li&gt;手机android 海豚浏览器&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;注意事项&lt;/h2&gt;

&lt;p&gt;通知权限是基于网站（或者域名），同一个网站下面的页面只需要获取一次权限即可。
如果别禁用了。将不会显示通知的，也无法再次获取权限了。
可以同浏览器的菜单查看权限。
&lt;code&gt;HTML
设置-》隐私设选下面的 “内容设置”-》通知
&lt;/code&gt;
如果你关闭或者刷新页面了。之前的通知就没法控制了 。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;使用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;引用notify.js文件&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;HTML
 &amp;lt;script src=&quot;notifiy.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器配置&lt;/p&gt;

    &lt;p&gt;检查浏览器是否支持桌面通知功能
 &lt;code&gt;HTML
 Notifier.HasSupport();
&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;获取允许桌面通知权限
 &lt;code&gt;HTML
 Notifier.RequestPermission();
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置通知显示方式（可选。不设置采用默认模式）&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;HTML
  Notifier.ModelAll();       //默认方式，显示所有的。在linux一般为三个。在window显示在通知区域。
  Notifier.ModelUpdate();    //更新模式，显示在上一个通知的位置，
  Notifier.ModelCount(c);    //限制当前页面显示的通知个数，默认为三个(可以通过参数c改变个数)。超出限制时关闭最早的通知，
  NOtifier.ModelTimeout(ct); //超时消失模式。显示一定时间自动消失。
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发送通知&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;HTML
 Notifier.Notify(icon, title, message); //显示桌面通知，icon：图片的地址  title:通知的标题 message：通知的内容
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭的方法&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;HTML
  Notifier.Clse(type);    //type=1 关闭上一个 其他值 关闭最早打开的
  Notifier.ClosePre();    //关闭最近个打开的通知
  Notifier.CloseLast();   //关闭最早显示的通知
  NOtifier.CloseAll();    //关闭所有通知
 &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他方法&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;HTML
 Notifier.GetPermission();   //获取关于通知使用权限，0，已经得到权限 1，需要获取权限 2，禁止使用
 Notifier.IsGetPermission(); //是否已经获取通知的使用权限
 Notifier.Disable();         //是否禁用通知
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>c语言 sizeof函数认知</title>
   <link href="http://www.ireage.com/c/2012/09/06/c-sizeof%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A4%E7%9F%A5.html"/>
   <updated>2012-09-06T00:00:00+08:00</updated>
   <id>http://www.ireage.com/c/2012/09/06/c sizeof函数的认知</id>
   <content type="html">&lt;p&gt;下面仅为个人理解，编译器中验证外，没有任何理论依靠，若有错误请指出。&lt;/p&gt;

&lt;p&gt;## 首先
 —
 sizeof是一个关键字并不是一个函数。或许你有疑问，既然是一个关键字，为什么出现sizeof的时候后面操作对象都加上括号哪？原因如下。&lt;/p&gt;

&lt;h2 id=&quot;sizeof&quot;&gt;sizeof函数证明&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof int ，结果为4，说明 sizeof说明他不是一个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;siezof(int )是关键字，为什么分开标记，比方 int i；int i，j；使用空格、逗号区分关键字和操作对象， 请测试 int(i)，你很惊
奇的发现这句话竟然可以编译通过没有报错，这句话的作用是相当于 int i，原因如下，int i，我们从原理上分析这句话，空格起
的是一个分割的作用，有用区分变量和变量类型。 int(i)同样也起到了区分变量和变量类型的，由于()的优先级别高，所以括号里边、外边成为两部分，这样与 int i；的功能相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof后面为什么一直有括号
sizeof struct  student；这一句话将会，编译失败，因为 sizeof 将 struct作为操作数，而并非将整个 struct  student 作为操作数，
这是因为优先级别的问题，
int a；sizeof a+1；结果值为5； 原因如下 sizeof(a)+1;
在sizeof后面加上括号，很容易区分操作对象，不容易出现歧义，去除优先级别错误&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sizeof-1&quot;&gt;sizeof容易出差的地方&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;char a[100]=”三月软件工作室—-Reage”;
char &lt;em&gt;p，&lt;/em&gt;p1=a；&lt;/p&gt;

&lt;p&gt;sizeof p；或许你认为结果为1，可是错了，结果是一个4,因为p是一个指针，是一个地址，地址一个unsigned long型的变量，&lt;/p&gt;

&lt;p&gt;所以结果为4；&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof p1;  值为4， 这个你或许认为没有意义，但是我是为下面一个做铺垫的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof(a) =100；  ？？为什么 sizeof(p1)为4，这里面涉及到汇编知识，a[100]在汇编中应该定义为  a .fill 100 0；所以测试a的值是一个应该是一个100，而p1的值不是&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof( &amp;amp;a)  vc= 100 ，gcc= 4； 我个人认为gcc的值是正确的，应为&amp;amp;a的地址得到的是一个地址的地址，还是地址 所以值
　　应该为4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof(&amp;amp;a[0])  4；没有疑问&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;del&gt;struct b{}；sizeof(b) ；vc=1，gcc=0；//应b是一个变量类型，定义一个b类型的数据，虽然他什么也没有但是他是存在
不能不占内存吧，所以编译器设置大小为1；gcc中为0是实际大小，但是我觉是错误的，因为这个变量占用了内存,
虽然是在代码段，而不是数据段；（这个是错误的。请大家谅解) &lt;/del&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;struct b{char c};sizeof(b)=1;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 

</feed>
