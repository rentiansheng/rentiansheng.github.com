<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Reage blog</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2019-03-16T16:51:17+08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>为什么要使用request id</title>
   <link href="http://localhost:4000/%E5%85%B6%E4%BB%96/2018/12/16/request_id.html"/>
   <updated>2018-12-16T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E5%85%B6%E4%BB%96/2018/12/16/request_id</id>
   <content type="html">&lt;h4 id=&quot;1-request-id-是为了解决下面问题&quot;&gt;1. request id 是为了解决下面问题&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;问题一： 客户端访问的Web服务时，如何将客户端请求与服务端日志关联 
问题二： 微服务架构下，访问日志如何查询
问题三： 不同项目交互出现异常，如何做日志关联
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2-request-id-vs-没有request-id&quot;&gt;2. request id vs 没有request id&lt;/h4&gt;

&lt;h5 id=&quot;没有request-id-请求&quot;&gt;没有request id 请求&lt;/h5&gt;

&lt;p&gt;只能根据调用函数日志关键，在根据用户的输入的参数，时间来确定相关的日志。
 如果项目是以分布式，微服务架构来实现， 上面查日志方式帮助很小。&lt;/p&gt;

&lt;p&gt;原因如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;代码层层封装后，无法通过日志关键与用户请求关联&lt;/li&gt;
  &lt;li&gt;微服务架构下，用户请求逻辑层分解多个子任务给下层服务处理，下层服务无法与用户请求关联&lt;/li&gt;
  &lt;li&gt;不同项目交互，如何在并发，错误重试，参数相同的情况下，无法通过关键字，时间来确定日志&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#####  request id&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前项目，根据request id 可以找到所有与请求相关的日志&lt;/li&gt;
  &lt;li&gt;不同项目，可以根据request id 确定唯一的请求&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3-request-id-好处&quot;&gt;3. request id 好处&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;用户请求日志关联&lt;/li&gt;
  &lt;li&gt;项目间请求日志关联&lt;/li&gt;
  &lt;li&gt;多服务间日志聚合&lt;/li&gt;
  &lt;li&gt;调用关系分析&lt;/li&gt;
  &lt;li&gt;日志分析&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;4-request-id-依赖&quot;&gt;4. request id 依赖&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;使用request id，要有配套日志记录系统&lt;/li&gt;
  &lt;li&gt;周边系统支持，保持统一&lt;/li&gt;
  &lt;li&gt;request id 每次用户请求，必须保证唯一。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;5-高级用法&quot;&gt;5. 高级用法&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ai.google/research/pubs/pub36356&quot;&gt;Google Dapper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zipkin.io/&quot;&gt;Google Dapper 实现 zipkin&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>git comMit messge 消息格式规范</title>
   <link href="http://localhost:4000/git/2018/12/07/git_commit_format.html"/>
   <updated>2018-12-07T00:00:00+08:00</updated>
   <id>http://localhost:4000/git/2018/12/07/git_commit_format</id>
   <content type="html">&lt;p&gt;根据外部文档总结出来git commit 提交的格式规范&lt;/p&gt;

&lt;h1 id=&quot;git-commit-messge-消息格式&quot;&gt;git commit messge 消息格式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;  type:messsge issue 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;样例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # 新加一个文档 
  git commit -m &quot;docs: add readme document issue #1 #2&quot;  readme.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;type-取值范围&quot;&gt;type 取值范围&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标记&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
      &lt;th&gt;加入版本&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;feature&lt;/td&gt;
      &lt;td&gt;新功能&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix&lt;/td&gt;
      &lt;td&gt;错误修复&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docs&lt;/td&gt;
      &lt;td&gt;文档更改&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;style&lt;/td&gt;
      &lt;td&gt;（格式化，缺少半冒号等;没有代码更改）&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;refactor&lt;/td&gt;
      &lt;td&gt;代码重构重构&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;添加缺失的测试，重构测试;没有生产代码更改&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;chore&lt;/td&gt;
      &lt;td&gt;构建脚本，任务等相关代码&lt;/td&gt;
      &lt;td&gt;v1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;depend&lt;/td&gt;
      &lt;td&gt;依赖的第三方代码&lt;/td&gt;
      &lt;td&gt;v2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lib&lt;/td&gt;
      &lt;td&gt;公共类库代码&lt;/td&gt;
      &lt;td&gt;v2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;define&lt;/td&gt;
      &lt;td&gt;公共变量定义&lt;/td&gt;
      &lt;td&gt;v2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;merge&lt;/td&gt;
      &lt;td&gt;不同分支之间的代码合并, issue 内容可以忽略&lt;/td&gt;
      &lt;td&gt;v2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;message&quot;&gt;message&lt;/h2&gt;
&lt;p&gt;本次提交的描述&lt;/p&gt;

&lt;h2 id=&quot;issue&quot;&gt;issue&lt;/h2&gt;
&lt;p&gt;本次提交相关的issue ,可以有多个&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>net/http timeout awaiting response headers</title>
   <link href="http://localhost:4000/golang/2018/10/08/golang_net_http_timeout_awaiting_response_headers.html"/>
   <updated>2018-10-08T00:00:00+08:00</updated>
   <id>http://localhost:4000/golang/2018/10/08/golang_net_http_timeout_awaiting_response_headers</id>
   <content type="html">&lt;h3 id=&quot;前提&quot;&gt;前提&lt;/h3&gt;

&lt;p&gt;在做系统压测的是发现有部分接口，返回 &lt;strong&gt;net/http: timeout awaiting response headers&lt;/strong&gt; 错误，&lt;/p&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;p&gt;看到错误首先想到的是http请求超时， 修改http client的timeout发下没有任何效果。&lt;/p&gt;

&lt;p&gt;但是这个错误就是http client 超时引起。是http client 在一定时间内没有返回数据，
客户端取消连接引起。 这个是由于http.Client的transport中ResponseHeaderTimeout 设置不合理引起的。&lt;/p&gt;

&lt;h3 id=&quot;相关知识&quot;&gt;相关知识&lt;/h3&gt;

&lt;p&gt;net.Dialer.Timeout 限制建立TCP连接的时间&lt;/p&gt;

&lt;p&gt;http.Transport.TLSHandshakeTimeout 限制 TLS握手的时间&lt;/p&gt;

&lt;p&gt;http.Transport.ResponseHeaderTimeout 限制读取response 返回内容的时间&lt;/p&gt;

&lt;p&gt;http.Transport.ExpectContinueTimeout 限制client在发送包含 Expect: 100-continue的header到收到继续发送body的response之间的时间等待。注意在1.6中设置这个值会禁用HTTP/2(DefaultTransport自1.6.2起是个特例)&lt;/p&gt;

&lt;h3 id=&quot;场景重现代码&quot;&gt;场景重现代码&lt;/h3&gt;

&lt;p&gt;使用下面代码中的client 调用服务端即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;
// server code 
func httpServer() {
	srv := &amp;amp;http.Server{
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		Addr:         &quot;:65530&quot;,
	}

	http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
		str := &quot;{}&quot;
		time.Sleep(3 * time.Second)
		w.Write([]byte(str))
	})
	go func() {
		err := srv.ListenAndServe()
		if nil != err {
			fmt.Println(err)
		}
	}()
	time.Sleep(10)

}

// client code
func httpClient() {
	for i := 0; i &amp;lt; 10; i++ {
		transport := &amp;amp;http.Transport{
			TLSHandshakeTimeout: 5 * time.Second,
			TLSClientConfig:     nil,
			Dial: (&amp;amp;net.Dialer{
				Timeout:   500 * time.Second,
				KeepAlive: 30 * time.Second,
			}).Dial,
			ResponseHeaderTimeout: 1 * time.Second,
		}
		c := &amp;amp;http.Client{
			Timeout:   10 * time.Second,
			Transport: transport,
		}
		_, err := c.Get(&quot;http://127.0.0.1:65530/aa&quot;)
		if nil != err {
			fmt.Println(err)
		}


	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;虽然client 出现net/http: timeout awaiting response headers 错误， 但是后端服务还在继续执行，返回数据会出现SIGPIPE，因为该链接已经断开&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>共享分布式锁</title>
   <link href="http://localhost:4000/distributed%20lock/2018/09/02/distributedlock.html"/>
   <updated>2018-09-02T00:00:00+08:00</updated>
   <id>http://localhost:4000/distributed%20lock/2018/09/02/distributedlock</id>
   <content type="html">&lt;h4 id=&quot;前提&quot;&gt;前提&lt;/h4&gt;

&lt;p&gt;分布式锁是在分布式系统中，我们为了保证分布式系统的效率和数据的正确性，在相同工作的多个节点中不被重复处理而采用的技术的。&lt;/p&gt;

&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;

&lt;p&gt;现在看网上的分布式锁都是现在资源限制。 锁的使用者限定到当前服务使用者。 在分层的web锁无法继承。
在系统设计中我们经常会才分层设计， 会有负责处理逻辑的层，处理数据的存储层。为了保证服务的高可用每一个服务我们都会部署多个实例。 
为了保证数据的完整性，我们需要在逻辑锁住资源， 在数据处理层修改数据。   这里面就涉及到两个问题&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁如何共享？&lt;/li&gt;
  &lt;li&gt;如何获取锁？&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;实现&quot;&gt;实现&lt;/h4&gt;

&lt;h6 id=&quot;分布式锁实现&quot;&gt;分布式锁实现&lt;/h6&gt;

&lt;p&gt;为了保证分布式锁的正确性，我们可以选择以下方案。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;redis SETNX 方案&lt;/li&gt;
  &lt;li&gt;redisLock 方案&lt;/li&gt;
  &lt;li&gt;zookeeper 顺序节点&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;锁的结构设计&quot;&gt;锁的结构设计&lt;/h5&gt;

&lt;p&gt;注解：由于锁是在分布式事务中事务，其中定义变量与实务相关, 代码是golang&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
锁的结构

type Lock struct {
	//  当前锁的标记。 是开启事务得到的事务ID， 事务主ID，不可以为空
	TxnID string `json:&quot;txnID&quot;`

	// 锁资源的子事务ID， 可以为空， 为空将自动生成改项目
	SubTxnID string `json:&quot;subTxnID&quot;`

	// 被锁资源的标记或者名字
	LockName string `json:&quot;lockName&quot;`

	
	// 锁的超时时间
    Expire time.Duration `json:&quot;expire&quot;`

    // 锁的创建时间
	Createtime time.Time `json:&quot;createTime&quot;`
}


锁的返回值， 无法锁住资源时，返回nil （就是空NULL）
type LockResult struct {
	// 锁资源的子事务ID， 
	SubTxnID string `json:&quot;subTxnID&quot;`

	// 获取lock 传入的TxnID事务中是否有子事务拥有锁，
	Locked bool `json:&quot;locked&quot;`

	// 拥有锁的子事务ID， 及时第一lock资源的子事务ID
	LockSubTxnID string `json:&quot;lockSubTxnID&quot;`
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;如何获取锁&quot;&gt;如何获取锁&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;用户需要携带TxnID 和 SubTxnID, TxnID必填， SubTxnID非必填，如果SubTxnID没有填写，则自动生成。&lt;/li&gt;
  &lt;li&gt;使用原子操作写入原子锁， 如果写入成功，则表示当前TxnID和SubTxnID拥有锁。&lt;/li&gt;
  &lt;li&gt;使用原子操作写入原子锁， 如果写入失败，获取当前锁的内容， 先判断锁中的TxnID是否与传入的TxnID相等， 如何不等于返回无法锁住资源， &lt;br /&gt;
否则TxnID等于TxnID， 继续执行&lt;/li&gt;
  &lt;li&gt;判断SubTxnID是否等于传入的SubTxnID， 等于则返回当前TxnID和SubTxnID拥有锁， 否则返回TxnID拥有锁， SubTxnID不拥有锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何共享锁&quot;&gt;如何共享锁&lt;/h4&gt;

&lt;p&gt;逻辑层调用存储层的时候通过HTTP header 将TxnID 透传下去&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>优雅的写go test</title>
   <link href="http://localhost:4000/golang/go%20test/2018/07/24/gotest.html"/>
   <updated>2018-07-24T00:00:00+08:00</updated>
   <id>http://localhost:4000/golang/go%20test/2018/07/24/gotest</id>
   <content type="html">&lt;h3 id=&quot;go-test-介绍&quot;&gt;go test 介绍&lt;/h3&gt;

&lt;p&gt;go语言的单元测试采用内置的测试框架,通过引入testing包以及go test来提供测试功能。
go语言的单元测试是一个个单独的文件。 每一个单元测试文件是与源代码同名加上_test.go的文件，
没有单元测试的文件必须以_test.go结尾&lt;/p&gt;

&lt;p&gt;eg:代码文件是 aa.go, 单元测试的文件就应该是aa_test.go&lt;/p&gt;

&lt;p&gt;go test 执行会主动调用当前执行go test 命令目录及子目录中所有已_test.go结尾文件中的
的以Test开头函数(谨记Test后的第一字母需要是大写)， 
当go test 带有-benchmem参数时， 会调用已Benchmark开头函数(谨记Benchmark后的第一字母需要是大写)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>excel文件实现包含xml的详情</title>
   <link href="http://localhost:4000/excel/2018/07/15/excel_xml.html"/>
   <updated>2018-07-15T00:00:00+08:00</updated>
   <id>http://localhost:4000/excel/2018/07/15/excel_xml</id>
   <content type="html">&lt;h3 id=&quot;excel-文件描述&quot;&gt;excel 文件描述&lt;/h3&gt;

&lt;p&gt;excel 是一个包含多个xml文件目录的zip压缩文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/表示为excel文件解压后的根目录
/docProps 文档相关的属性
/xl excel  数据相关厨房目录
/xl/charts excel 图表相关都存在这里
/xl/drawings excel 图表定义 
/xl/worksheets excel工作簿下sheet存放目录
/xl/media 用来excel中导入的图片，声音，视频等地方资源
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;excel-文件组成部分&quot;&gt;excel 文件组成部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/_rels/.rels  包关系项

/[Content_Types].xml  内容类型项

/docProps/app.xml  应用程序定义的文件属性部分，sheet与sheet名字关系，

/docProps/core.xml   核心文件属性部分

/xl/workbook.xml   工作簿部分相关定义

/xl/_rels/workbook.xml.rels 部分关系项


/xl/sharedStrings.xml   共享字符串表部分，用户输入内容

/xl/styles.xml   样式部分，关于font，boder,fill 相关定义


/xl/worksheets/sheetX.xml   excel中sheet中单元格与样式的关系，内容，数据校验等相关

/xl/theme/themeX.xml   sheetX的主题部分，themeX中的**X**表示的是工作X（数字）的主题，eg:1,2,3 

/xl/media/nameX.xml excel引入外部资源的定义
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;必须的xml文件&quot;&gt;必须的xml文件&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;/_rels/.rels

/docProps/app.xml

/docProps/core.xml

/xl/sharedStrings.xml

/xl/styles.xml

/xl/thene/themeX.xml

/xl/workbook.xml

/xl/worksheets/sheetX.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;stylexml&quot;&gt;style.xml&lt;/h4&gt;

&lt;p&gt;style有font,fill, border,cellXfs等四部分组成。&lt;/p&gt;

&lt;p&gt;font 表示字体相关的描述&lt;/p&gt;

&lt;p&gt;fill 表示填充颜色及样式&lt;/p&gt;

&lt;p&gt;border 表示边框颜色及样式&lt;/p&gt;

&lt;p&gt;cellXfs有font,fill,border组成，来描述一个具体对象的样式&lt;/p&gt;

&lt;p&gt;每一个xml节点的count属性表示共有多少个子对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;styleSheet&amp;gt; 
   &amp;lt;font&amp;gt;&amp;lt;/font&amp;gt;
   &amp;lt;fills count=&quot;&quot;&amp;gt;
       &amp;lt;fill&amp;gt;&amp;lt;/fill&amp;gt;
   &amp;lt;/fills&amp;gt;
   &amp;lt;borders count=&quot;&quot;&amp;gt;
       &amp;lt;border&amp;gt;&amp;lt;/border&amp;gt;
   &amp;lt;/borders&amp;gt;
   &amp;lt;cellXfs count=&quot;&quot;&amp;gt;
	   &amp;lt;xf&amp;gt;&amp;lt;/xf&amp;gt;
   &amp;lt;/cellXfs&amp;gt;
&amp;lt;/styleSheet&amp;gt;
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;font-组成&quot;&gt;font 组成&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;font&amp;gt;
   &amp;lt;b/&amp;gt;加粗
   &amp;lt;i/&amp;gt; 倾斜
   &amp;lt;u val=&quot;double|single&quot;/&amp;gt; 下划线，单|双
   &amp;lt;sz val=&quot;x&quot;/&amp;gt; 字体大小， val=size
   &amp;lt;name val=&quot;&quot;/&amp;gt; 字体名
   &amp;lt;family val=&quot;&quot;&amp;gt; 此元素指定当前字体的字体系列。 此信息可以按字体定义使用
当此字体不可用时，替换逻辑以找到适当的替代字体。 这个信息是
通过在存在时查询字体来确定，并且在字体不可用时不应修改。
&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;fill-组成&quot;&gt;fill 组成&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;	&amp;lt;fill&amp;gt;
		&amp;lt;patternFill patternType=&quot;solid&quot;&amp;gt;  patternType表示填充的类型
			&amp;lt;fgColor rgb=&quot;AARRGGBB&quot; /&amp;gt;   前景色，AARRGGBB, AA表示是透明度，RR红色，GG绿色，BB蓝色，每一位都一个16进制数字
			&amp;lt;bgColor rgb=&quot;AARRGGBB&quot; /&amp;gt;  背景色， AARRGGBB
		&amp;lt;/patternFill&amp;gt;
	&amp;lt;/fill&amp;gt;
	
&lt;/code&gt;&lt;/pre&gt;

&lt;border diagonalUp=&quot;1&quot; diagonalDown=&quot;1&quot;&gt;
   &lt;left /&gt;
   &lt;right style=&quot;thin&quot;&gt;
    &lt;color rgb=&quot;FFFF0000&quot; /&gt;
   &lt;/right&gt;
   &lt;top /&gt;
   &lt;bottom /&gt;
   &lt;diagonal style=&quot;thin&quot;&gt;
    &lt;color rgb=&quot;FFFF0000&quot; /&gt;
   &lt;/diagonal&gt;
  &lt;/border&gt;

&lt;h6 id=&quot;border-组成&quot;&gt;border 组成&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;border&amp;gt;    
     &amp;lt;left /&amp;gt; 左边框
     &amp;lt;right /&amp;gt; 右边框
     &amp;lt;top /&amp;gt;  上边框
     &amp;lt;bottom /&amp;gt;  下边框
     &amp;lt;diagonal /&amp;gt; 对角线
  &amp;lt;/border&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;border 节点可以有属性diagonalUp，diagonalDown 这两个属性是border中孩子节点diagonal描述，表示对角线话的放心，
left,right,top,bottom四个节点可以有color子节点及style属性，color子节点有一个rgb属性用来描述颜色值， style表示边框的样式&lt;/p&gt;

&lt;h6 id=&quot;xf组成&quot;&gt;xf组成&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;xf numFmtId=&quot;&quot; fontId=&quot;&quot; fillId=&quot;&quot; borderId=&quot;&quot; xfId=&quot;&quot;&amp;gt;
   &amp;lt;alignment vertical=&quot;&quot;  horizontal=&quot;&quot; textRotation=&quot;&quot; wrapText=&quot;&quot; /&amp;gt; 
  &amp;lt;/xf&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;numFmtId 单元格格式&lt;/p&gt;

&lt;p&gt;fontId fonts节点的子节点index&lt;/p&gt;

&lt;p&gt;fillId fills节点的子节点index&lt;/p&gt;

&lt;p&gt;borderId borders节点的子节点indx&lt;/p&gt;

&lt;p&gt;vertical cell内容的对齐方式&lt;/p&gt;

&lt;p&gt;horizontal cell内容的对齐方式&lt;/p&gt;

&lt;p&gt;textRotation cell内容文字的旋转方式&lt;/p&gt;

&lt;p&gt;wrapText 文字环绕方式&lt;/p&gt;

&lt;p&gt;部分字段可选值&lt;/p&gt;

&lt;p&gt;vertical,horizontal 的部分值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;left
center
right
fill
justify
centerContinuous
distributed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;numFmtId 的部分值
0  通用格式
1  整数
18 时间， 格式是h:mm AM/PM
19 时间， 格式是h:mm:ss AM/PM
20 时间， 格式是h:mm
21 时间， 格式是h:mm:ss
22 日期，格式是m/d/yy h:mm
49 文字&lt;/p&gt;

&lt;h4 id=&quot;sheetxxml&quot;&gt;sheetX.xml&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;worksheet&amp;gt;
   &amp;lt;dimension ref=&quot;&quot; /&amp;gt;
   &amp;lt;sheetViews&amp;gt;
  &amp;lt;sheetView windowProtection=&quot;&quot; showFormulas=&quot;&quot; showGridLines=&quot;&quot; showRowColHeaders=&quot;&quot; showZeros=&quot;&quot; rightToLeft=&quot;false&quot; tabSelected=&quot;&quot; showOutlineSymbols=&quot;true&quot; defaultGridColor=&quot;true&quot; view=&quot;normal&quot; topLeftCell=&quot;A1&quot; colorId=&quot;64&quot; zoomScale=&quot;&quot; zoomScaleNormal=&quot;&quot; zoomScalePageLayoutView=&quot;&quot; workbookViewId=&quot;&quot;&amp;gt;
       &amp;lt;/sheetView&amp;gt;
   &amp;lt;/sheetViews&amp;gt;
   &amp;lt;sheetFormatPr /&amp;gt;
   &amp;lt;col collapsed=&quot;&quot; hidden=&quot;&quot; min=&quot;&quot; max=&quot;&quot; width=&quot;&quot; style=&quot;&quot; customWidth=&quot;&quot; /&amp;gt;
   &amp;lt;sheetData&amp;gt;
      &amp;lt;row r=&quot;&quot; spans=&quot;&quot;&amp;gt;
         &amp;lt;c r=&quot;&quot; t=&quot;&quot;&amp;gt;
             &amp;lt;v&amp;gt;&amp;lt;/v&amp;gt;
         &amp;lt;/c&amp;gt;
      &amp;lt;/row&amp;gt;
   &amp;lt;/sheetData&amp;gt; 
   &amp;lt;dataValidations count=&quot;2&quot;&amp;gt;
     &amp;lt;dataValidation type=&quot;&quot; allowBlank=&quot;&quot; showInputMessage=&quot;&quot; showErrorMessage=&quot;&quot; sqref=&quot;&quot;&amp;gt;
       &amp;lt;formula1&amp;gt;
        &quot;&quot;
       &amp;lt;/formula1&amp;gt;
 	   &amp;lt;formula2&amp;gt;
        &quot;&quot;
       &amp;lt;/formula2&amp;gt;
     &amp;lt;/dataValidation&amp;gt;
    &amp;lt;/dataValidations&amp;gt;

   &amp;lt;pageMargins left=&quot;&quot; top=&quot;&quot; bottom=&quot;&quot; header=&quot;&quot; footer=&quot;&quot; /&amp;gt;
   &amp;lt;pageSetup paperSize=&quot;&quot; orientation=&quot;&quot; verticalDpi=&quot;&quot;  /&amp;gt;
   &amp;lt;drawing /&amp;gt;
   &amp;lt;extLst&amp;gt;
     &amp;lt;ext&amp;gt;
     &amp;lt;/ext&amp;gt;
   &amp;lt;/extLst&amp;gt;

&amp;lt;/worksheet&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>The Golang operation EXCEL  library  for columns and cell  supports data validation  (drop-down list, numeric text length check)</title>
   <link href="http://localhost:4000/golang/2018/04/29/golangexceldatavalidation_en.html"/>
   <updated>2018-04-29T00:00:00+08:00</updated>
   <id>http://localhost:4000/golang/2018/04/29/golangexceldatavalidation_en</id>
   <content type="html">&lt;h3 id=&quot;completed-function&quot;&gt;completed function&lt;/h3&gt;

&lt;p&gt;   1. Cell, column support drop-down list selection
   2. Cell, column support range check
   3. Open Excel support cell, column data check read
  &lt;/p&gt;
&lt;h3 id=&quot;items-to-pay-attention-to&quot;&gt;Items to pay attention to&lt;/h3&gt;
&lt;p&gt;  
   1. Excel data validation supports setting the length of the check character to 255,
   2. Excel is not supported as a check condition by selecting cells in the workbook&lt;/p&gt;

&lt;h2 id=&quot;1-remise&quot;&gt;1. remise&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Recently used in Golang development projects used excel import, export. Data export is no problem, just write excel on the line. However, importing templates has encountered some problems.&lt;/p&gt;

&lt;p&gt;Questions are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. The data in db is defined as a string. If the field is filled with numbers, the field is a number when the data is acquired. The backend conversion is required.
2. Enumerate the type fields, fill in too difficult. Users need to know the corresponding value
3. The field range value, fill in more difficult, (such as user, type, etc.)
3  can not limit the length of the field to fill in the content
4. Cannot limit the range of numbers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why not directly put an excel file, the data in the project is imported, the export field is not fixed, you need to import according to the personal configuration real field, export&lt;/p&gt;

&lt;h2 id=&quot;2-golang-excel-class-library-selection&quot;&gt;2. Golang EXCEL Class Library Selection&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;After the Internet search found two more use now more golang operation excel class library&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/360EntSecGroup-Skylar/excelize&quot;&gt;excelize&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tealeg/xlsx&quot;&gt;xlsx&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In most cases, xlsx is selected, and xlsx is more in star and fork than excelle. However, excelize is more active in recent activity and the document is more detailed (in Chinese)&lt;/p&gt;

&lt;h2 id=&quot;3-use-excel-data-validation&quot;&gt;3. Use EXCEL data validation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;In the use of xlsx, there is no problem with basic functions, but when doing advanced functions, it is found that many advanced functions do not have time, and some implementations are too rude. The data verification function is not implemented at all. Originally wanted to copy excelize the code, and found that they did not achieve, still lying in the todo list. Helplessness can only be implemented on xlsx itself.&lt;/p&gt;

&lt;p&gt;Implement the function code in:
The &lt;a href=&quot;https://github.com/rentiansheng/xlsx&quot;&gt;support data validation&lt;/a&gt; code has been submitted to the PR but has not been merged.
Now it’s simple and crude to implement the list of excel data validation, rang validation (time, date need to be converted to numbers, now unimplemented) has confirmed that available data validation has list (display dorp box), rang (number, decimal, text length ), User input will be prompted for incorrect content.&lt;/p&gt;

&lt;p&gt;An example of a test code for data validation is at &lt;a href=&quot;https://github.com/rentiansheng/xlsx/blob/dev_master/datavalidation_test.go&quot;&gt;data validation test code&lt;/a&gt;
You can go test to view the production excel content.&lt;/p&gt;

&lt;h2 id=&quot;4-need-to-prepare-for-the-development-of-excel&quot;&gt;4. Need to prepare for the development of EXCEL&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;Excel is a zip file described by openxml.
The files in the office are all similar. Microsoft has published the document.&lt;/p&gt;

&lt;p&gt;tool:
Open xml sdk 2.0 tool, can view the openxml code of excel file, provide verification, documentation, generate code function (not golang)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Golang EXCEL 操作类库支持列，单元格新加数据验证功能(下拉列表，数字文本长度校验)</title>
   <link href="http://localhost:4000/golang/2018/04/29/golangexceldatavalidation.html"/>
   <updated>2018-04-29T00:00:00+08:00</updated>
   <id>http://localhost:4000/golang/2018/04/29/golangexceldatavalidation</id>
   <content type="html">&lt;h2 id=&quot;完成的功能&quot;&gt;完成的功能&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单元格，列支持下拉列表选择&lt;/li&gt;
  &lt;li&gt;单元格，列支持范围校验&lt;/li&gt;
  &lt;li&gt;打开Excel支持单元格，列数据校验读取&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;需要注意的项目&quot;&gt;需要注意的项目&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Excel 数据校验支持设置校验字符的长度为255，&lt;/li&gt;
  &lt;li&gt;不支持Excel通过选择工作簿中的单元格作为校验条件&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-前提&quot;&gt;1. 前提&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;最近Golang开发的项目中用到excel 导入，导出。数据导出没什么问题， 直接写excel 就行了。但是导入模版遇到一些问题。&lt;/p&gt;

&lt;p&gt;问题如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. db中数据定义为字符串，字段如果用户填写都是数字，获取数据的时候，该字段就是数字，需要后端转换
2. 枚举类型字段，填写难度过大。用户需要知道对应的值
3. 字段范围值，填写比较困难，（如用户，类型等）
3. 无法限定字段填写内容的长度
4. 无法限定数字填写范围
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么不直接放一个excel文件， 项目中数据导入，导出字段是不固定，需要根据个人的配置实字段来导入，导出&lt;/p&gt;

&lt;h2 id=&quot;2-golang-excel-类库选择&quot;&gt;2. Golang EXCEL 类库选择&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;经过上网查找发现两个现在使用比较多golang 操作 excel 类库&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/360EntSecGroup-Skylar/excelize&quot;&gt;excelize&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tealeg/xlsx&quot;&gt;xlsx&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最总，选择了xlsx, xlsx在star 和fork 比 excelle多。但是excelize最近活跃度上更活跃，文档更详细（有中文）&lt;/p&gt;

&lt;h2 id=&quot;3-使用excel-数据验证&quot;&gt;3. 使用EXCEL 数据验证&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;xlsx在使用中，基本功能没什么问题，但是在做高级功能的时候，发现很多高级功能没有时间，有的实现过于粗暴。 数据校验功能根本没有实现。本来想去copy excelize的代码，结果，发现他们也没有实现， 还在todo列表中躺着。无奈只能基于xlsx自己实现。&lt;/p&gt;

&lt;p&gt;实现功能代码在：
&lt;a href=&quot;https://github.com/rentiansheng/xlsx&quot;&gt;支持数据验证&lt;/a&gt; 代码已经提交PR,但是未合并。
现在简单粗暴的实现 excel 数据校验中的list，rang 验证（时间，日期 需要转换成数字，现在未实现）已经确认可用数据校验有 list（展示dorp box ），rang(数字，小数，文本长度)， 用户输入的内容不对会有提示。&lt;/p&gt;

&lt;p&gt;关于数据校验的代码的测试例子在&lt;a href=&quot;https://github.com/rentiansheng/xlsx/blob/dev_master/datavalidation_test.go&quot;&gt;数据验证test代码&lt;/a&gt;
可以go test 查看生产excel内容。&lt;/p&gt;

&lt;h2 id=&quot;4-开发excel-需要准备的&quot;&gt;4. 开发EXCEL 需要准备的&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;excel 是openxml 来描述的一个zip压缩文件。
office中的文件都是类似的。 微软已经将文档公开。&lt;/p&gt;

&lt;p&gt;工具：
open xml sdk 2.0 的工具，可以查看excel 文件的openxml代码，提供校验，文档，生成代码功能（不是golang）&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>golang 下载文件格式错误</title>
   <link href="http://localhost:4000/golang/2018/03/16/godownfilecontenttype.html"/>
   <updated>2018-03-16T00:00:00+08:00</updated>
   <id>http://localhost:4000/golang/2018/03/16/godownfilecontenttype</id>
   <content type="html">&lt;h3 id=&quot;场景&quot;&gt;场景&lt;/h3&gt;

&lt;p&gt;最近在使用golang做一个cmdb，系统中有大量的数据需要导出下载。
在功能开发完成后， 系统在开发和测试环境运行正常。但是部署到环境后，
在下载数据的时候，文件下载下来会变成zip或者没有后缀等两种情况。&lt;/p&gt;

&lt;h3 id=&quot;问题分析&quot;&gt;问题分析&lt;/h3&gt;

&lt;p&gt;文件下载格式不正确，首先，想到的是http response的header中的
content-type格式不对， 使用curl -v 请求后发现返回数据如下&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-curl&quot; data-lang=&quot;curl&quot;&gt;&amp;gt; POST /hosts/export HTTP/1.1
&amp;gt; Accept: */*
&amp;gt; Cache-Control: no-cache
&amp;gt; Content-Length: 246
&amp;gt; content-type: multipart/form-data; 
&amp;gt;
&amp;lt; HTTP/1.1 100 Continue
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Date: Wed, 14 Mar 2018 09:49:55 GMT
&amp;lt; Content-Type: application/zip
&amp;lt; Content-Length: 7795&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;通过curl 调用确认了是content-type的问题。
看了golang关于http package的介绍没有设置mime.type的地方。
因为go语言使用的是系统的mime，不像nginx，apache有自己的mime配置文件。 
所以使用golang 的http package功能在不同系统上由于系统的mine.types
差异影响系统功能。 系统的mime.types在/etc/mime.types大家可以自由查看&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;更新系统的/etc/mine.types&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过代码解决&lt;/p&gt;

    &lt;p&gt;熟悉HTTP协议的同学应该知道，HTTP response header中的content-type
是可以指定下载文件的格式。
虽然相信golang作为一门优秀的语言一定会按照HTTP协议实现，
但是还是翻了下源码，
http.ServeFile -&amp;gt; serveFile-&amp;gt; serveContent&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-code&quot; data-lang=&quot;code&quot;&gt;func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, sizeFunc func() (int64, error), content io.ReadSeeker) {
    ...... 
    ctype := w.Header().Get(&amp;quot;Content-Type&amp;quot;)
   	if !haveType {
   		ctype = mime.TypeByExtension(filepath.Ext(name))
   		if ctype == &amp;quot;&amp;quot; {
   			// read a chunk to decide between utf-8 text and binary
   			var buf [sniffLen]byte
   			n, _ := io.ReadFull(content, buf[:])
   			ctype = DetectContentType(buf[:n])
   			_, err := content.Seek(0, io.SeekStart) // rewind to output whole file
   			if err != nil {
   				Error(w, &amp;quot;seeker can&amp;#39;t seek&amp;quot;, StatusInternalServerError)
   				return
   			}
   		}
   		w.Header().Set(&amp;quot;Content-Type&amp;quot;, ctype)
   	} else if len(ctypes) &amp;gt; 0 {
   		ctype = ctypes[0]
   	}
   
     ....
   }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;http头部的设置规则&quot;&gt;HTTP头部的设置规则&lt;/h3&gt;

&lt;p&gt;Content-Type: application/vnd.ms-excel   #excel 2003-2007的格式&lt;/p&gt;

&lt;p&gt;Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet  #excel 2007以后的格式&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>服务治理</title>
   <link href="http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/16/servicemangger.html"/>
   <updated>2016-11-16T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/16/servicemangger</id>
   <content type="html">&lt;h1 id=&quot;服务治理&quot;&gt;服务治理&lt;/h1&gt;

&lt;h2 id=&quot;为什么要做服务治理&quot;&gt;为什么要做服务治理&lt;/h2&gt;

&lt;p&gt;一个系统在开发之初，功能简单，规模较小。 随着业务需求的变化和增加，
系统的功能和规模会变得庞大。&lt;/p&gt;

&lt;p&gt;将会出现以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;维护、开发、部署将变得困难&lt;/li&gt;
  &lt;li&gt;水平扩展困难&lt;/li&gt;
  &lt;li&gt;功能及技术迭代困难
（注：技术迭代指的是替换使用的语言、第三方工具等）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决上述的问题，我们将会采取分拆系统的方法，将一个庞大的系统拆分成N个小系统。&lt;/p&gt;

&lt;p&gt;拆分会带来以下的好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立部署，方便水平扩展&lt;/li&gt;
  &lt;li&gt;系统隔离&lt;/li&gt;
  &lt;li&gt;快速的迭代（每个系统可以根据业务场景来决定使用最优的开发语言和第三方工具）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，拆分并没有从根本上解决问题，随着业务发展，我们拆分出来的N个小系统会继续添加相关的业务，
随着时间的发展也变的复杂和庞大。我们又继续使用拆分的方案， 然后拆分出来的系统又随着业务的变化和发展，
开始从简单变得复杂，我们一遍又一遍做着重复拆分的事情。&lt;/p&gt;

&lt;p&gt;解决问题的方法是：&lt;/p&gt;

&lt;p&gt;在接到开发任务之初，将任务做成一个或者多个独立的服务单元（服务单元:请看下面注释），
每个服务单元单独部署和迭代开发，禁止添加其它非必要的功能。&lt;/p&gt;

&lt;p&gt;注解：&lt;/p&gt;

&lt;p&gt;服务单元：尽可能小的服务集合，只包含对于一个抽象属性的增删改查，杜绝添加其他相关联的功能和业务。&lt;/p&gt;

&lt;p&gt;随之带来的问题是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;独立的服务单元越来越多，如何对服务单元做管理&lt;/li&gt;
  &lt;li&gt;如何做负载均衡&lt;/li&gt;
  &lt;li&gt;如何做服务信息的修改及快速生效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最开始的解决方案是由OP和RD配合来做的。
通过DNS,NGINX,CONFIG文件来配合完成任务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DNS，NGINX都可以做负载均衡的功能。

DNS,NGINX,CONFIG都可以用来管理服务单元信息的变更
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的方法，虽然可以解决问题，但是每次必须修改配置，然后重新加载配置才会生效。
无法实现立即生效，避免错误继续扩大的问题。为了解决这些问题，就要使用有效的服务治理方案。&lt;/p&gt;

&lt;h2 id=&quot;服务治理-1&quot;&gt;服务治理&lt;/h2&gt;

&lt;p&gt;服务治理主要是对服务信息进行管理的一系列的系统。为了实现这个系统，
我们需要一个高可用、低延迟的数据存储工具。&lt;/p&gt;

&lt;p&gt;经过筛选我们最终选择了zookeeper。
我们先来看下zookeeper官方的定义：&lt;/p&gt;

&lt;p&gt;ZooKeeper is a centralized service for maintaining configuration information,
 naming, providing distributed synchronization, and providing group services.&lt;/p&gt;

&lt;p&gt;使用zookeeper原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公司已经有zookeeper集群，具备运维能力&lt;/li&gt;
  &lt;li&gt;zookeeper 使用范围比较广，&lt;/li&gt;
  &lt;li&gt;zookeeper watcher机制能够及时通知修改，保证信息一直&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然，我们可以通过zookeeper来解决存储数据的问题，
但是服务的信息并不会自动出现在zookeeper中，我们需要开发一个关于服务治理的系统。&lt;/p&gt;

&lt;p&gt;服务治理具备功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;服务发现&lt;/p&gt;

    &lt;p&gt;主动注册和第三方注册两种服务发现方式，我们现在使用的是第三方注册的方式，
 因为调用方和服务方都是PHP编写的，主动注册实现复杂&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务管理&lt;/p&gt;

    &lt;p&gt;服务状态的统计信息、服务信息管理、授权查看，在使用第三方注册时候，提供服务注册和修改功能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通信&lt;/p&gt;

    &lt;p&gt;异步通信和同步通信，现在只实现同步通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问控制&lt;/p&gt;

    &lt;p&gt;限制调用方使用的key对服务方访问频次、是否具有访问权限等检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据交互协议适配&lt;/p&gt;

    &lt;p&gt;调用方不用关注服务方提供服务使用的协议。目前支持http下json、yar-msgpack相互转换&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何去做&quot;&gt;如何去做&lt;/h2&gt;

&lt;p&gt;到目前为止，我找到解决问题的方法和需要实现的功能的。
根据上面的信息，我们给出了具体是的设计方案。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkmanagerservice.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个设计共分五部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;调用者&lt;/p&gt;

    &lt;p&gt;通过HTTP或YAR访问Gateway， 将需要调用的服务信息和参数告诉 Gateway，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务方&lt;/p&gt;

    &lt;p&gt;a) 提供服务&lt;/p&gt;

    &lt;p&gt;b) 将自己的信息通过管理平台注册到zookeeper中&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  1. 服务名、状态
  2. 地址信息、机房、权重及状态
  3. 服务下接口的列表
      a) 接口名
      b) 接口路径
      c) 输出数据的编码（json或者yar-msgpack）
      d) 状态
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Gateway&lt;/p&gt;

    &lt;p&gt;a) 请求的转发&lt;/p&gt;

    &lt;p&gt;b) 快速失败&lt;/p&gt;

    &lt;p&gt;c) 对发送的数据做编码（json或者yar-msgpack）&lt;/p&gt;

    &lt;p&gt;d) 负载均衡&lt;/p&gt;

    &lt;p&gt;e) 将服务和接口的信息缓存到内存中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管理平台&lt;/p&gt;

    &lt;p&gt;a) 服务及接口的注册&lt;/p&gt;

    &lt;p&gt;b) 服务及接口的查看&lt;/p&gt;

    &lt;p&gt;c) 服务及接口的修改&lt;/p&gt;

    &lt;p&gt;d) 统计信息查看&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ZooKeeper&lt;/p&gt;

    &lt;p&gt;ZooKeeper在整个服务治理的设计中是最重要的组成部分。
在使用zookeeper之前。我们先来看下zookeeper存储数据的原理。
下面是zookeeper官方的介绍:&lt;/p&gt;

    &lt;p&gt;The name space provided by ZooKeeper is much like that of a standard file system. 
A name is a sequence of path elements separated by a slash (/). 
Every node in ZooKeeper’s name space is identified by a path.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://zookeeper.apache.org/doc/r3.1.1/images/zknamespace.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zookeeper就像一个树，用每一个”/{name}”表示节点及节点名。每一个节点可以有子节点和存储少量的内容。&lt;/p&gt;

&lt;p&gt;我们在zookeeper中存储的信息有服务信息、地址信息、接口信息。具体格式如下：&lt;/p&gt;

&lt;p&gt;服务信息：/service/{服务名}&lt;/p&gt;

&lt;p&gt;地址信息：/address/{服务名}&lt;/p&gt;

&lt;p&gt;接口信息：/api/{服务名}/{接口名}&lt;/p&gt;

&lt;p&gt;为什么要将zookeeper中存储数据的结构设计为上面描述格式， 是因为zookeeper在watcher机制的处理中给出了
   两个关于wather 通知使用的API（golang zk）
   一个是关注子节点变化ChildrenW函数，另外一个是关注节点本身内容变化GetW函数。
   我们设计的方案在实现上让每个节点功watcher更加简单。
   我们现在来看一个具体的例子：假设有一个服务s，下面有A,B两个接口
&lt;img src=&quot;/img/zkstoragestructrue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;出现的问题如何保证缓存信息和zookeeper中的内容一致&quot;&gt;出现的问题（如何保证缓存信息和zookeeper中的内容一致）&lt;/h2&gt;

&lt;p&gt;Gateway 为了做到低延迟和高可用性，在Gateway 中缓存zookeeper中的数据。
在Gateway中缓存数据的格式与zookeeper中的结构一致。
我们是如何保证缓存的信息是正确可用的,
就需要用到zookeeper的watcher机制。在zookeeper中内容中修改时，
通过watcher机制通知Gateway 来更新缓存&lt;/p&gt;

&lt;p&gt;具体的设计如下图（具体实现的流程图在最后）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkwatcherdesign.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了设计图可能会有下列的疑问：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么收到通知后不直接去更新缓存？&lt;/p&gt;

    &lt;p&gt;这个问题就需要了解zookeeper关于watcher机制的原理，zookeeper的watcher机制是一次性的，
 在收到watcher的通知后，watcher就消失了。为了避免在更新缓存时zookeeper的
 数据再次变化无法收到通知，因为这个时候watcher机制已经没有，
 zookeeper已经没有通知Gateway机制，这样缓存中的数据和zookeeper中的数据将会不一致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么致命错误需要重新初始化缓存？&lt;/p&gt;

    &lt;p&gt;下面的介绍的内容会跟开发使用的语言和zookeeper的sdk有一定的关系。&lt;/p&gt;

    &lt;p&gt;开发语言：golang   — SDK：samuel/go-zookeeper/zk&lt;/p&gt;

    &lt;p&gt;我们先来看下SDK是如何处理错误，
 个人将SDK的错误分为非致命错误和致命错误错误两种（个人观点）。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 非致命错误：ErrNoAuth、ErrAPIError、ErrAuthFailed等

 致命错误：ErrSessionMoved、ErrSessionExpired等
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;非致命错误是与zookeeper集群通信时，使用的参数及上下文环境出现问题返回的错误，
 影响范围只有本次调用。&lt;/p&gt;

    &lt;p&gt;致命错误通常是与zookeeper集群的通信出现网络故障，影响与zookeeper集群的所有通信。
 但是SDK(go-zookeeper)并不会在问题出现时刻立即报错，
 SDK会自动尝试建立新的可以使用的session，
 SDK在session建立成功后将给所有的watcher发送一个错误通知。&lt;/p&gt;

    &lt;p&gt;ErrSessionMoved: 是与zookeeper集群的某个实例session失效后，
 下次与zookeeper成功建立session发送给所有watcher。&lt;/p&gt;

    &lt;p&gt;ErrSessionExpired:是与整个zookeeper集群session失效后，
 下次与zookeeper成功建立session发送给所有watcher。&lt;/p&gt;

    &lt;p&gt;收到致命错误后，我们无法知道在于zookeeper集群session断开的时间段中，
 zookeeper中的数据数据变化情况。如果只是更新和新加，
 我们可以在初始化的时候将节点的内容缓存即可，
 但是如果有删除的话。我们就需要遍历所有的缓存内容来删除不需要的缓存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现的流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkwatcherprocess.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>服务治理之zookeeper使用中遇到的问题及设计</title>
   <link href="http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/08/service_zookeeper.html"/>
   <updated>2016-11-08T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/08/service_zookeeper</id>
   <content type="html">&lt;h1 id=&quot;如何规划需要管理配置&quot;&gt;如何规划需要管理配置&lt;/h1&gt;

&lt;p&gt;根据需求将所有的信息分成四类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 分类

    /classify下每个节点是一个分类名，内容是分类描述，分类属于辅助信息，没有太大意义。

    eg: /classify/c1  分类名c1, /classify/c1节点内容为c1的描述

2. 服务信息

    /service下每个节点都是一个服务

    eg: /service/srv1  服务名为srv1，/service/c1节点内容服务srv1具体内容

3. 服务地址

    /address 下每个节点都是一个服务

    eg: /service/srv1  服务名为srv1，/service/c1节点内容服务srv1具体内容

4. 服务下的API

    /api下每一个节点是一个服务，服务下节点是API的命名的节点

    eg: /api/srv1/api1   /api/srv1下的子节点是srv1服务下的所有API，/api/srv1/api1  服务srv1下api1的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1. zk reconnect后授权问题

2. zk session 过期

3. zk reconnect 数据同步的问题

2. watcher 消失后修改的问题
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;功能设计&quot;&gt;功能设计&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zk&lt;/td&gt;
      &lt;td&gt;1.管理节点&lt;br /&gt; 2.内容节点&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;watcher&lt;/td&gt;
      &lt;td&gt;1.关注子节点变化&lt;br /&gt; 2.关注本身变化&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;queue&lt;/td&gt;
      &lt;td&gt;1.处理错误&lt;br /&gt; 2.重新初始化监控&lt;br /&gt; 3.初始化缓存&lt;br /&gt; 4.通知cache变更&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cache&lt;/td&gt;
      &lt;td&gt;1.根据类型更新缓存&lt;/td&gt;
      &lt;td&gt;所有缓存相关的操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;好处&quot;&gt;好处&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1. 各模块职责单一

2. 统一的错误处理

3. 收敛缓存处理逻辑

4. 方便扩展
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;解决问题方法&quot;&gt;解决问题方法&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;zk reconnect后授权问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zk session 过期&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zk reconnect 数据同步的问题&lt;/p&gt;

    &lt;p&gt;问题1、2、3 在queue模块中添加统一的错误处理逻辑&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;添加授权信息&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关闭原有的watcher&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;初始化watcher进程&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;watcher 消失后修改的问题&lt;/p&gt;

    &lt;p&gt;通过设计queue和cache模块，分开实现，延时获取数据的。&lt;/p&gt;

    &lt;p&gt;具体流程，见下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://7xi8r0.com1.z0.glb.clouddn.com/watcher_note.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>服务治理之服务管理</title>
   <link href="http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/07/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.html"/>
   <updated>2016-11-07T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/11/07/服务治理之服务管理</id>
   <content type="html">&lt;h2 id=&quot;如何管理服务&quot;&gt;如何管理服务&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;需要考虑的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 1. 服务信息注册

* 2. 如何保证服务信息一致
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务信息是服务发现很重要的部分，它是包含服务提供者的地址信息和提供服务的接口。
服务信息需要高可用而且随时更新。gateway可以缓存从服务信息。
然而，这些信息最终会变得过时，客户端也无法发现服务实例。
因此，服务信息必须保证是一个一个分布式可用。&lt;/p&gt;

&lt;h6 id=&quot;目前可以使用的组件有&quot;&gt;目前可以使用的组件有：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;etcd

consul

zookeeper

Kubernetes

eureka
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，根据公司运维等方面考虑选择使用zookeeper&lt;/p&gt;

&lt;h2 id=&quot;主要实现功能&quot;&gt;主要实现功能&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 服务发现

   主动注册和被动注册，我使用的是被动注册，因为调用方和服务方都是PHP，主动注册不方便

2. 服务管理

  由于是被动注册，需要提供一个注册平台，主要提服务注册、授权、地址等信息管理

3. 通信

   异步通信和同步通信，现在只实现同步通信

4. 访问控制

   限制调用放key对服务方QPS、接口、有效时长

5. 数据交换编码

    目前支持http下json、yar-msgpack相互转换
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基于zookeeper服务管理的实现&quot;&gt;基于zookeeper服务管理的实现&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/img/zkmanagerservice.png&quot; alt=&quot;基于zookeeper服务管理的实现图&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>服务治理之开发环境配置解决</title>
   <link href="http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/10/06/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
   <updated>2016-10-06T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2016/10/06/服务治理之开发环境配置</id>
   <content type="html">&lt;h3 id=&quot;出现的问题&quot;&gt;出现的问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;新搭建的开发环境如何快速使用&lt;/li&gt;
  &lt;li&gt;如何解决开发中路由问题（同一个服务或者接口不同调用者调用不同服务方）&lt;/li&gt;
  &lt;li&gt;如何解决开发中使用host的问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;为什么测试环境和生产环境没有问题&quot;&gt;为什么测试环境和生产环境没有问题&lt;/h3&gt;

&lt;p&gt;测试和生产环境在服务和接口的环境调用比较简单，都是一一对应的。
在使用的过程中，服务治理这不需要关注调用者身份，只需根据服务中配置的
地址信息，选择一个可用的服务者来转发这个请求即可。&lt;/p&gt;

&lt;p&gt;但是在开发环境中，服务和接口调用者关系比较复杂。我将调用者分成两种类型，
直接调用者和间接调用者。间接调用者的需求是最简单的，这个服务或者接口
我不需要关心，只要能返回结果。 直接调用者需求是最复杂的，直接调用者有非常
明确的服务提供者，有可能是整个服务下的接口，也有可能是服务下摸个接口。&lt;/p&gt;

&lt;h3 id=&quot;没有服务治理之前怎么解决&quot;&gt;没有服务治理之前怎么解决&lt;/h3&gt;

&lt;h6 id=&quot;使用服务治理前&quot;&gt;使用服务治理前&lt;/h6&gt;

&lt;p&gt;调用者和服务方是直接通信的，所有环境的配置都是在代码配置文件中，调用者可以
直接指定服务方地址。可以同修改配置文件和/etc/hosts文件来决定服务方&lt;/p&gt;

&lt;h6 id=&quot;使用服务治后&quot;&gt;使用服务治后&lt;/h6&gt;

&lt;p&gt;调用者和服务方是间接通信的， 服务治理做为中间方。调用者和服务方直接通信都是
服务治理的提供者。修改本地配置失效。&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;服务治理只在服务信息和接口信息中新加路由表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;调用者&lt;/th&gt;
      &lt;th&gt;调用者IP&lt;/th&gt;
      &lt;th&gt;服务者&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;测试ip1&lt;/td&gt;
      &lt;td&gt;127.0.0.1&lt;/td&gt;
      &lt;td&gt;http://apiv1.ireage.com&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;测试ip2&lt;/td&gt;
      &lt;td&gt;127.0.0.2&lt;/td&gt;
      &lt;td&gt;http://apiv2.ireage.com&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在服务信息中新加域名信息domain: http://api.ireage.com&lt;/p&gt;

&lt;h6 id=&quot;1-新搭建的开发环境如何快速使用&quot;&gt;1. 新搭建的开发环境如何快速使用&lt;/h6&gt;
&lt;p&gt;每一个服务需要一个默认可以使用的地址&lt;/p&gt;

&lt;h6 id=&quot;2-如何解决开发中路由问题同一个服务或者接口不同调用者调用不同服务方&quot;&gt;2. 如何解决开发中路由问题（同一个服务或者接口不同调用者调用不同服务方）&lt;/h6&gt;
&lt;p&gt;服务和接口分别有host的配置，通过调者IP地址来决定服务方的地址&lt;/p&gt;

&lt;h6 id=&quot;3-如何解决开发中使用host的问题&quot;&gt;3. 如何解决开发中使用host的问题&lt;/h6&gt;

&lt;p&gt;为服务配置一个域名，在http的头部添加host即可。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>react</title>
   <link href="http://localhost:4000/react/2016/09/27/reacterr.html"/>
   <updated>2016-09-27T00:00:00+08:00</updated>
   <id>http://localhost:4000/react/2016/09/27/reacterr</id>
   <content type="html">&lt;h3 id=&quot;同一个commpont多次使用出现的错误&quot;&gt;同一个commpont多次使用出现的错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;错误提示如下：
 Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded

 解决方法如下
 npm uninstall react react-dom
 npm install react react-dom --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setstate有延时&quot;&gt;setState有延时&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.setState(params:{page:2});
随后使用fetch将this.state.params作为参数获取数据的时候，竟然是之前的数据
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;同一组件在url参数改变时未重新加载数据&quot;&gt;同一组件，在URL参数改变时，未重新加载数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;使用组件componentWillReceiveProps事件即可。
componentWillMount和componentDidMount只有在组件切换时执行，同一组件在不同参数下不会触发。
例如：http::/ireage.com/test#/list/1 变为 http::/ireage.com/test#/list/2 不触发componentWillMount和componentDidMount事件。
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>PHP VS GO</title>
   <link href="http://localhost:4000/%E6%9D%82%E8%B0%88/2016/08/30/phpvsgo.html"/>
   <updated>2016-08-30T00:00:00+08:00</updated>
   <id>http://localhost:4000/%E6%9D%82%E8%B0%88/2016/08/30/phpvsgo</id>
   <content type="html">&lt;h4 id=&quot;整体印象&quot;&gt;整体印象&lt;/h4&gt;
&lt;p&gt;PHP：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 不用编译，写完代码就可以直接看
2. 只要本次执行的代码没有fatal就可以执行，即使优点也是缺点。
3. 弱类型超牛B，一个变量随便用，不用声明，数组随意递归没有格式限制。 即使优点也是缺点
4. 特别讨厌$，
5. 强大string，array操作
6. 成熟访问权限控制public,private,protected
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 每次写完都需要编译。 需要检查整个项目编译，整个项目没有错误。
2. 严格的格式，强类型。 变量定义必须使用，代码格式etc
3. 简介的格式
4. 强大的协程
5. 完善的网络库
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;语法相关&quot;&gt;语法相关&lt;/h4&gt;
&lt;p&gt;PHP：&lt;/p&gt;

&lt;p&gt;觉得自己不是一个合格PHPer,使用两年多了，竟然总结不出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 自由灵活，变量，命名，语法灵活
2. 入门简单
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 访问权限，通过大小写控制，小写内部函数，大写外部函数。（刚开始特别坑，让我一个经常使用驼峰命名的人很不习惯）
2. defer个人感觉超级好用，可以用来做释放资源，后期处理。
3. 变量，类型超级丰富，觉得虽然和接触的语言都不一样，但是感觉超级习惯，var xxx type
4. 函数定义，丰富的数据传递参数，个人理解一个最完整 func (共有数据) 函数名(函数私有数据)（返回数据），
5. 没有类，但是可以使用struct 和 interface 来完成。interface在GO里面很重要的
6. channel，协程为并发而生。
7. 把异步搞的和同步一样
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;适用场景&quot;&gt;适用场景&lt;/h4&gt;

&lt;p&gt;PHP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. WEB开发
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GO:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1. WEB开发
 2. 服务开发
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;题外话&quot;&gt;题外话&lt;/h4&gt;

&lt;h6 id=&quot;进程线程协程&quot;&gt;进程、线程、协程&lt;/h6&gt;
&lt;p&gt;进程和线程比较常见，操作系统课上都讲过，协程虽然没有讲过，如果知道nginx原理相信会觉得似曾相识
其实可以从调度、并发性、系统开销、拥有资源等发面作比较&lt;/p&gt;

&lt;p&gt;进程：&lt;/p&gt;

&lt;p&gt;进程被称为重量级别进程（HWP）。进程也可看做一个线程的集合，在我看来进程管理者是操作系统
进程的调度是有OS来调度和管理。所以进程的调度，并发，系统开销、资源拥有都是系统层面。&lt;/p&gt;

&lt;p&gt;线程：&lt;/p&gt;

&lt;p&gt;线程被称为轻量级别的进程（LWP）是CPU调度和分配的基本单元。在我看来线程是一个CPU执行的实例。是一个进程获取到执行时内部调度，并发。&lt;/p&gt;

&lt;p&gt;进程和线程intel网站上有一份超级详细和全面的资料。&lt;a href=&quot;https://software.intel.com/sites/default/files/m/5/7/f/a/b/12568-2.1.1_e7_ba_bf_e7_a8_8b_e4_b8_8e_e8_bf_9b_e7_a8_8b_e7_9a_84_e5_8c_ba_e5_88_ab.pdf&quot;&gt;process vs threads.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;协程:
协程是一个不能被操作系统和CPU调度的玩意，全靠语言本身来控制。不关是进程，线程调度的时候都要进行上下文切换， 协程这玩意不涉及系统和CPU的上下文切换，协程个人感觉是就是异步和内存切换。
附带一篇不错协程介绍&lt;a href=&quot;http://blog.imisko.com/2017/08/02/golang-coroutine/&quot;&gt;Golang协程之殇&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>c pointer</title>
   <link href="http://localhost:4000/c/2016/08/21/cpointer.html"/>
   <updated>2016-08-21T00:00:00+08:00</updated>
   <id>http://localhost:4000/c/2016/08/21/cpointer</id>
   <content type="html">&lt;h3 id=&quot;指针相关&quot;&gt;指针相关&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;1-glibc-detected--19-munmap_chunk-invalid-pointer-0x00007ffff5cc97b0-&quot;&gt;1.&lt;em&gt;** glibc detected **&lt;/em&gt; ./19: munmap_chunk(): invalid pointer: 0x00007ffff5cc97b0 ***&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; a) free释放内存出现，注意free只能释放malloc分配的内存，在function中看到是指针，这个指针有可能是定义的数组，无法释放
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2-二维数组和指针的指针区别-type-与-type-&quot;&gt;2. 二维数组和指针的指针区别( type [][]与 type **)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  虽然两种方式在使用的时候访问方式是通用的，差异主要在内存组织

  二维数组是一个连续的区域，如char a[2][3] 实际上是一个连续的sizeof(char)*2*3的内存区域。在变量定义时候已经确立整数组存储数据集合容纳数据大小，
  并且没一行数据的个数必须一样，无法扩容;


  指针指针是是通过先分配type * 来存储二维数组中一维，然后在分配type 来维持二维数组二维。存储数据集合和动态调整，没一行的个数可以不同。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eg:内存组织图，type标识数据类型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/arrayandpointerpointer.png&quot; alt=&quot;内存组织图&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>iterm2 快捷键</title>
   <link href="http://localhost:4000/iterm2/2016/08/11/iterm2keys.html"/>
   <updated>2016-08-11T00:00:00+08:00</updated>
   <id>http://localhost:4000/iterm2/2016/08/11/iterm2keys</id>
   <content type="html">&lt;p&gt;最近买了一个键盘，操作触控就不方便了，只能在键盘下功夫了。&lt;/p&gt;

&lt;p&gt;本人系统shell是zsh&lt;/p&gt;

&lt;h4 id=&quot;光标操作&quot;&gt;&lt;strong&gt;光标操作&lt;/strong&gt;&lt;/h4&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;ctrl + a: 到行首

ctrl + e: 行末

ctrl + f/b: 前进后退，相当于左右方向键。

ctrl + p: 上一条命令，相当于方向键上

ctrl + r: 搜索命令历史，这个大家都应该很熟悉了

ctrl + d: 删除当前字符

ctrl + h: 删除之前的字符

ctrl + w: 删除光标前的单词

ctrl + k: 删除到文本末尾

ctrl + t: 交换光标处文本

ctrl + u: 删除一行

command + —/+/0: +字体变大，-字体变小， 0 恢复到默认值，如果分屏了只调整活动窗口字体大小

command + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。对 ⌘ + f没有影响
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;窗口操作&quot;&gt;&lt;strong&gt;窗口操作&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;shift + command + d: 水平拆分窗口

shift + d: 垂直拆分窗口

command + shift + w: 关闭当前活动终端窗口

command + `/~ : 前一个/后一个窗口, 这里的窗口不是tab页面，而是通过new window打开的多个终端窗口

command + t: 在活动终端新建一个tab标签

command + w: 关闭当前tab窗口

command + option + 上下左右: 在当前活动的tab标签切换到上/下/左/右面板，面板指的是水平/垂直拆分的窗口

command + enter: 进去/退出全屏木事

Command + u: 开启/关闭背景透明

shift + command + [/]: 前一个/后一个标签页

command + option + +: 进入/退出铺满屏幕

 command + ctrl+ 上/下/左/右 : 调整当前分屏边框大小，
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;其他&quot;&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h4&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;command + shift + m: 新建书签

command + shift + j: 回到最后一次简历书签的位置


command + shift + h: 展示粘贴历史，支持模糊检索

command + option + b: 打开即使回放

command + /: 显示光标的位置
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>json_decode解析失败</title>
   <link href="http://localhost:4000/php/2016/02/24/json_decode.html"/>
   <updated>2016-02-24T00:00:00+08:00</updated>
   <id>http://localhost:4000/php/2016/02/24/json_decode</id>
   <content type="html">&lt;p&gt;最近，一直在使用的系统突然出现一个奇怪的问题。一个商户信息总是没法展示的，两个系统采用json做的数据交换，
线上日志记录到模块是接受导数据，但是在后面的日志中，发现数据为空。经过在线上加log发现json_decode失败的返回值为NULL。
随后把log中的日志拿出来，json_decode没有问题的。&lt;/p&gt;

&lt;p&gt;首先想到的问题是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;json格式的问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存限制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编码问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的问题，很容就可以检查结果了。到底是不是这些原因的。不幸的事情发生了。这些都不是的，太奇葩了。&lt;/p&gt;

&lt;p&gt;虽有用json_decode解码失败搜索发现，有人说是因为json串有\t等特殊字符的问题的（之所以copy后解析成功，是因为不同的编辑器和编码格式会对特殊字符做处理）。&lt;/p&gt;

&lt;p&gt;在不同的终端下查看数据，发现数据中有特符符号。但是并不是\t,而是编码格式为\u0014\u0017数据。最好建议大家不要对数据进行解码查看，要看查看最原始的数据。因为不同的编码会对特殊符号做处理，在不同的编码下，特殊符号可能会显示为空白，不显示，显示为不同的符号等。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>php extensions(二) phpinfo输出内容</title>
   <link href="http://localhost:4000/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/18/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(%E4%BA%8C)phpinfo%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF.html"/>
   <updated>2015-04-18T00:00:00+08:00</updated>
   <id>http://localhost:4000/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/18/php扩展开发学习(二)phpinfo添加信息</id>
   <content type="html">&lt;h3 id=&quot;php-extensions二--phpinfo输出内容&quot;&gt;php extensions(二)  phpinfo输出内容&lt;/h3&gt;

&lt;h4 id=&quot;引言&quot;&gt;引言&lt;/h4&gt;

&lt;p&gt;我们在使用一个PHP扩展的时候，首先，将编译后的扩展放到PHP的扩展加载目录下，使用phpinfo函数来查看插件是否已经加载。&lt;/p&gt;

&lt;h4 id=&quot;代码实现&quot;&gt;代码实现&lt;/h4&gt;

&lt;p&gt;在phpinfo函数添加内容特别简单的。
   1.首先修改module entry&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;zend_module_entry reage_module_entry = {
             STANDARD_MODULE_HEADER,
             &amp;quot;reage&amp;quot;,//扩展的名字
             NULL, // functions
             NULL, // minit
             NULL, //mshutdown
             NULL, //rinit
             NULL, //rshutdown
             PHP_MINFO(reage_info), //注册在phpinfo函数中输出内容的函数,reage_info
             &amp;quot;0.0.1&amp;quot;, //版本号
             STANDARD_MODULE_PROPERTIES
         };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2.输出内容函数的实现&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;PHP_MINFO_FUNCTION(reage_info) {
           php_info_print_table_start();
           php_info_print_table_header(2, &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;);
           php_info_print_table_row(2, &amp;quot;author&amp;quot;, &amp;quot;Reage&amp;quot;);
           php_info_print_table_end();
        }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;使用到的函数&quot;&gt;使用到的函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;php_info_print_table_start();
php_info_print_table_header();
php_info_print_table_row();
php_info_print_table_end();

除了这些函数，还有很多函数，需要的话请自行查阅
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####  源代码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng/php-extension-learn/tree/master/learn2(phpinfo)&quot;&gt;https://github.com/rentiansheng/php-extension-learn/tree/master/learn2(phpinfo)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;特别说明&quot;&gt;特别说明&lt;/h4&gt;

&lt;p&gt;在搜索资料时，发现一个写的特别好的php扩展开发系列文章，希望对大家有用&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.walu.cc/phpbook/index.md&quot;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>php extensions(-) 代码目录结构</title>
   <link href="http://localhost:4000/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/08/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(-).html"/>
   <updated>2015-04-08T00:00:00+08:00</updated>
   <id>http://localhost:4000/php%20extension/c/%E5%BC%80%E6%BA%90/2015/04/08/php扩展开发学习(-)</id>
   <content type="html">&lt;h3 id=&quot;php-extensions--代码目录结构&quot;&gt;php extensions(-) 代码目录结构&lt;/h3&gt;

&lt;h4 id=&quot;引言&quot;&gt;引言&lt;/h4&gt;
&lt;p&gt;每一个php extension的目录中最少要包含config.m4、config.w32、php_extension.h、extension.c。php_extension.h和extension.c文件是以后编写php extension主要用到文件，这里就不介绍了。下面我们开一个叫reage的php extension。&lt;/p&gt;

&lt;h4 id=&quot;1-扩展的配置文件configm4和configw32&quot;&gt;1. 扩展的配置文件config.m4和config.w32&lt;/h4&gt;

&lt;p&gt;config.m4用户Unix、Linux等系统。config.m4文件告诉 UNIX 构建系统哪些扩展 configure 选项是支持的，你需要哪些扩展库，以及哪些源文件要编译成它的一部分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  config.m4配置函数PHP_ARG_WITH()和 PHP_ARG_ENABLE()的区别在于编译的时候使用 --with-* 选项还是 --enable-* 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/internals2.structure.files.php&quot;&gt;关于配置文件的详细内容&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是我的一个例子&lt;/p&gt;

&lt;p&gt;dnl在config.m4是注释的意思&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;PHP_ARG_WITH(reage, for reage support,
Make sure that the comment is aligned:
[  --with-reage             Include reage support])
dnl 检测扩展是否已启用
if test $PHP_REAGE != &amp;quot;no&amp;quot;; then
    PHP_SUBST(REAGE_SHARED_LIBADD)
    PHP_NEW_EXTENSION(reage, reage.c, $ext_shared)
fi&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;config.w32 是windows下的扩展的配置文件的，&lt;a href=&quot;http://php.net/manual/zh/internals2.structure.files.php&quot;&gt;具体使用查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;####2. php_reage.h&lt;/p&gt;

&lt;p&gt;php_reage.h其实不是必须的，但是一般的都C语言项目都是包含.h和.c文件的。为了让代码看起来更加的正规，我们也使用.h文件。.h文件一般只包含函数的定义、结构体的定义。&lt;/p&gt;

&lt;p&gt;下面是我的一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#ifndef REAGE_H
#define REAGE_H


#include &amp;quot;php.h&amp;quot;
#define phpext_reage_ptr &amp;amp;reage_module_entry;
extern zend_module_entry reage_module_entry;

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;####3. reage.c
reage.c是具体的代码文件的。
下面是我的一个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;php_reage.h&amp;quot;
#include &amp;quot;ext/standard/info.h&amp;quot;

//加载config.h,如果有配置项
#ifdef HAVE_CONFIG_H
#include &amp;quot;config.h&amp;quot;
#endif


//module entry
zend_module_entry reage_module_entry = {
    STANDARD_MODULE_HEADER,
    &amp;quot;reage&amp;quot;,//扩展的名字
    NULL, // functions
    NULL, // minit
    NULL, //mshutdown
    NULL, //rinit
    NULL, //rshutdown
    NULL,
    &amp;quot;0.0.1&amp;quot;, //版本号
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_REAGE
ZEND_GET_MODULE(reage)
#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;####4. 编译php extension
   在php extension的目录下，执行一下命名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   1. phpize
   2. ./configure
   3. make
   4. make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####5. test 
    将modules/reage.so 拷贝到你php的extension路径中。不知道路径的话，看下phpinfo()中extension_dir的值就可以了。然后修改php.ini添加extension=reage.so。如果没有问题，在phpinfo()中会现实reage及其版本。&lt;/p&gt;

&lt;p&gt;####6. ext_skel
  ext_skel工具是专门用来生成php extension 目录结构的。ext_skel在php源码下的ext目录下。
  使用ext_skel工具生成目录结构后，需要修改config.m4中大约10-20行，是关于PHP_ARG_WITH和PHP_ARG_ENABLE的。根据自己的需要将前面的注释符号（dnl）去掉&lt;/p&gt;

&lt;p&gt;####7. 源代码
&lt;a href=&quot;https://github.com/rentiansheng/php-extension-learn/tree/master/learn1&quot;&gt;https://github.com/rentiansheng/php-extension-learn/tree/master/learn1&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mysql 优化基础知识（-）</title>
   <link href="http://localhost:4000/mysql/2015/03/30/mysql%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(-).html"/>
   <updated>2015-03-30T00:00:00+08:00</updated>
   <id>http://localhost:4000/mysql/2015/03/30/mysql优化基础知识(-)</id>
   <content type="html">&lt;h4 id=&quot;1-primary-key&quot;&gt;1. primary key&lt;/h4&gt;
&lt;p&gt;primary key是聚簇索引，聚餐适用I/O密集型的应用，由于底层存储及实现的原因，聚簇索引严重依赖顺序存储，聚簇索引列更新代价比较高，聚簇索引列在尾部以外插入新的row代价比较高的
  综上所述，在使用primary key列一般都是用int类型auto_increment，这样保证所有的值都是顺序插入的，auto_increment在高并发的应用下肯定会有争用问题。
  主键的优点在于不管表中有多少行数据。通过primary key获取数据都非常快&lt;/p&gt;

&lt;h4 id=&quot;2索引在存储时都是正序存储&quot;&gt;2.索引在存储时都是正序存储&lt;/h4&gt;
&lt;p&gt;因此，就算建立 index idx_score_course(score,course) 索引，使用explain “select * from test order by score desc, course asc”你就会发现并没有到idx_score_course索引，在Extra现实这Using filesort&lt;/p&gt;

&lt;h4 id=&quot;3-where-in&quot;&gt;3. where in&lt;/h4&gt;
&lt;p&gt;mysql中的where in与or是不同的，mysql不回将where in转换成or，mysql会对where in的条件进行排序，然后做二分查找，这是一个时间复杂度为o(log n)的操作，等价转换成or的查询时间复杂度为o(n)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>codeigniter rabbitmq lirary</title>
   <link href="http://localhost:4000/php/2014/11/28/codeigniter-rabbitmq-library.html"/>
   <updated>2014-11-28T00:00:00+08:00</updated>
   <id>http://localhost:4000/php/2014/11/28/codeigniter rabbitmq library</id>
   <content type="html">&lt;p&gt;简介
&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;_&lt;/p&gt;

&lt;p&gt;针对CI 封装的一个简单的rabbitmq，只有基本功能的&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng//ci-rabbitmq&quot;&gt;项目地址：https://github.com/rentiansheng//ci-rabbitmq&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;代码结构&quot;&gt;代码结构&lt;/h2&gt;
&lt;p&gt;1.文件介绍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.src/src/libraries/rabbitmq.php  rabbitmq操作代码
  2.src/src/config/rabbitmq.php     rabbitmq配置文件
  3.src/src/models/rabbitmqmodel.php   consume回调函数代码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.将需要的PHP代码文件放到制定位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1. cp src/src/libraries/rabbitmq.php   项目代码/application/libraries/
  2. cp src/src/config/rabbitmq.php   项目代码/application/config/
  3. cp src/src/models/rabbitmqmodel.php   项目代码/application/models/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;1.queue  declare一个queue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   参数
       name 队列的名字
       durable queue是否持久化，true，是，false 否 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.sendMsg 向队列中add内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    参数
        msg 消息的内容
        exchangeName 发送消息使用的exchangeName
        queueName 接受消息的queue
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
        exchangeType exchage type 我一般用直接写入，
                      你可以选择一下模式， AMQP_EX_TYPE_DIRECT,
                      AMQP_EX_TYPE_FANOUT,
                      AMQP_EX_TYPE_HEADER or AMQP_EX_TYPE_TOPIC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.getMsg 获取消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   参数 
        queueName 获取内容的queue的name
        autoack   是否自动ack，autoack ＝ true，消息将从队列删除，
                  autoack ＝ false；时，需要用ack或者nack来回应给rabbitmq，否则，队列将无法工作
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
    备注
        从队列中的下一个可用的消息。如果没有消息存在于队列中，该函数将立即返回FALSE，
        这种方式比较消耗CPU,不建议使用的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.consume 获取消息，推荐&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    参数
        queueName 获取内容的queue的name
        callback  回调函数的名字，注意这个是函数名字的，对应名字的函数必须在models/rabbitmqmodel.php中实现的
        autoack   是否自动ack，autoack ＝ true，消息将从队列删除，
                  autoack ＝ false；时，需要用ack或者nack来回应给rabbitmq，否则，队列将无法工作
        durable   queueName队列是否持久话，要与declare queue保持一直，负责回出错的
    备注
        callback回调函数的名字，注意这个是函数名字的，对应名字的函数必须在models/rabbitmqmodel.php中实现的
        回调函数将会有两个参数，
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.consume回调函数格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
   function test(envelope, $queue) {}
    参数
       envelope  与消息相关的对象，具体的查看&amp;lt;a href=&quot;http://php.net/manual/pl/class.amqpenvelope.php&quot;&amp;gt;http://php.net/manual/pl/class.amqpenvelope.php&amp;lt;/a&amp;gt;
       queue  queue的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;demo-目录下是示例代码&quot;&gt;demo 目录下是示例代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 将demo/controllers/taskqueue.php 项目代码/application/controllers/taskqueue.php
2.  运行例子，最好可以terminal运行,首先转到项目文件所在的路径
    已发送消息作为例子
    sudo [可选择加上php env]  php所在位置 index.php taskqueue   sendMsg 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;我遇到的问题&quot;&gt;我遇到的问题&lt;/h2&gt;
&lt;p&gt;1.在执行一段时间后无法从redis获取内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    我使用的是ci的cache库操作redis，由于cache 初始化是在controller开始的位置，时间久了，会自动断开链接请注意。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.请不要在浏览器中运行consume， php-fpm有可会出现问题，&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>览器桌面通知（notifications）</title>
   <link href="http://localhost:4000/js/2014/05/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5-notifications.html"/>
   <updated>2014-05-28T00:00:00+08:00</updated>
   <id>http://localhost:4000/js/2014/05/28/浏览器桌面通知（notifications）</id>
   <content type="html">&lt;h1 id=&quot;chrome-浏览器桌面通知&quot;&gt;chrome 浏览器桌面通知&lt;/h1&gt;

&lt;p&gt;最近在做公司后台管理系统，当有任务到来时，需要通知当事人，但是，当事人有可能在做别的事情，更糟糕的是浏览器有可能会被最小化，
这样就很难看到通知了。经过查找发现有些浏览器可以使用noitfications，
可以在桌面的通知区域内显示一个提示框，并且显示在桌面的最前面，很方便就能看到了。我就将它简单的封装一下，使其符合常用的使用场景。
功能效果类似webQQ的消息提示通知。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rentiansheng/notification&quot;&gt;项目地址：https://github.com/rentiansheng/notification&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;用于其余B/S下的网络办公提醒功能。
页面最小化的状态下发送通知
依然显示在屏幕的右下角，马上可以看到内容&lt;/p&gt;

&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;PC chrome浏览器。&lt;/li&gt;
  &lt;li&gt;手机android 海豚浏览器&lt;/li&gt;
  &lt;li&gt;firefox 可用但是智能展示一个通知（不建议使用，不同版本存在差异）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;

&lt;p&gt;通知权限是基于网站（或者域名），同一个网站下面的页面只需要获取一次权限即可。
如果别禁用了。将不会显示通知的，也无法再次获取权限了。
可以同浏览器的菜单查看权限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;设置-》隐私设选下面的 “内容设置”-》通知
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你关闭或者刷新页面了。之前的通知就没法控制了 。&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;引用notify.js文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;script src=&quot;notifiy.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器配置&lt;/p&gt;

    &lt;p&gt;检查浏览器是否支持桌面通知功能&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.HasSupport();
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;获取允许桌面通知权限&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.RequestPermission();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置通知显示方式（可选。不设置采用默认模式）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.ModelAll();       //默认方式，显示所有的。在linux一般为三个。在window显示在通知区域。
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.ModelUpdate();    //更新模式，显示在上一个通知的位置，
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.ModelCount(c);    //限制当前页面显示的通知个数，默认为三个(可以通过参数c改变个数)。超出限制时关闭最早的通知，
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt; NOtifier.firefox 可用但是智能展示一个通知（不建议使用，不同版本存在差异）(ct); //超时消失模式。显示一定时间自动消失。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发送通知&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;Notifier.Notify(icon, title, message); //显示桌面通知，icon：图片的地址  title:通知的标题 message：通知的内容
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭的方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  Notifier.Clse(type);    //type=1 关闭上一个 其他值 关闭最早打开的
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt;  Notifier.ClosePre();    //关闭最近个打开的通知
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt;  Notifier.CloseLast();   //关闭最早显示的通知
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt;  NOtifier.CloseAll();    //关闭所有通知
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.GetPermission();   //获取关于通知使用权限，0，已经得到权限 1，需要获取权限 2，禁止使用
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.IsGetPermission(); //是否已经获取通知的使用权限
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code&gt; Notifier.Disable();         //是否禁用通知
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>c语言 sizeof函数认知</title>
   <link href="http://localhost:4000/c/2012/09/06/c-sizeof%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A4%E7%9F%A5.html"/>
   <updated>2012-09-06T00:00:00+08:00</updated>
   <id>http://localhost:4000/c/2012/09/06/c sizeof函数的认知</id>
   <content type="html">&lt;p&gt;下面仅为个人理解，编译器中验证外，没有任何理论依靠，若有错误请指出。&lt;/p&gt;

&lt;p&gt;## 首先
 —
 sizeof是一个关键字并不是一个函数。或许你有疑问，既然是一个关键字，为什么出现sizeof的时候后面操作对象都加上括号哪？原因如下。&lt;/p&gt;

&lt;h2 id=&quot;sizeof函数证明&quot;&gt;sizeof函数证明&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof int ，结果为4，说明 sizeof说明他不是一个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;siezof(int )是关键字，为什么分开标记，比方 int i；int i，j；使用空格、逗号区分关键字和操作对象， 请测试 int(i)，你很惊
奇的发现这句话竟然可以编译通过没有报错，这句话的作用是相当于 int i，原因如下，int i，我们从原理上分析这句话，空格起
的是一个分割的作用，有用区分变量和变量类型。 int(i)同样也起到了区分变量和变量类型的，由于()的优先级别高，所以括号里边、外边成为两部分，这样与 int i；的功能相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof后面为什么一直有括号
sizeof struct  student；这一句话将会，编译失败，因为 sizeof 将 struct作为操作数，而并非将整个 struct  student 作为操作数，
这是因为优先级别的问题，
int a；sizeof a+1；结果值为5； 原因如下 sizeof(a)+1;
在sizeof后面加上括号，很容易区分操作对象，不容易出现歧义，去除优先级别错误&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sizeof容易出差的地方&quot;&gt;sizeof容易出差的地方&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;char a[100]=”三月软件工作室—-Reage”;
char &lt;em&gt;p，&lt;/em&gt;p1=a；&lt;/p&gt;

&lt;p&gt;sizeof p；或许你认为结果为1，可是错了，结果是一个4,因为p是一个指针，是一个地址，地址一个unsigned long型的变量，&lt;/p&gt;

&lt;p&gt;所以结果为4；&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof p1;  值为4， 这个你或许认为没有意义，但是我是为下面一个做铺垫的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof(a) =100；  ？？为什么 sizeof(p1)为4，这里面涉及到汇编知识，a[100]在汇编中应该定义为  a .fill 100 0；所以测试a的值是一个应该是一个100，而p1的值不是&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof( &amp;amp;a)  vc= 100 ，gcc= 4； 我个人认为gcc的值是正确的，应为&amp;amp;a的地址得到的是一个地址的地址，还是地址 所以值
　　应该为4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sizeof(&amp;amp;a[0])  4；没有疑问&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;del&gt;struct b{}；sizeof(b) ；vc=1，gcc=0；//应b是一个变量类型，定义一个b类型的数据，虽然他什么也没有但是他是存在
不能不占内存吧，所以编译器设置大小为1；gcc中为0是实际大小，但是我觉是错误的，因为这个变量占用了内存,
虽然是在代码段，而不是数据段；（这个是错误的。请大家谅解) &lt;/del&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;struct b{char c};sizeof(b)=1;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 

</feed>
